<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Вопросы для тестировщика</title>
    <link rel="stylesheet" href="questions.css">
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(100016215, "init", {
             clickmap:true,
             trackLinks:true,
             accurateTrackBounce:true,
             webvisor:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/100016215" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
</head>
<body>
<nav>
    <div class="burger-menu">
    </div>
    <ul>
        <li><a href="hwois.html">Кто такой тестировщик?</a></li>
        <li><a href="roadmap.html">Roadmap</a></li>
        <li><a href="index.html" style="background-color: #FFA001;">Вопросы</a></li>
        <li><a href="tetris.html">Тетрис</a></li>
        <li><a href="bugs.html">Баги</a></li>
        <li><a href="calendar_v1.html">Календарь</a></li>
        <li><a href="swagger_api.html">Практика API (Swagger)</a></li>
    </ul>
</nav>

<header class="welcome">
    <div class="header-container">
        <div class="logo"
             style="cursor: pointer;"
             onclick="window.location.href='index.html'">
            <img src="img/QAtoDev_(Flappy_Bird_style).png" alt="Логотип">
        </div>
        <h3 class="site-title">На главную</h3>
    </div>
</header>

<h2>Вопросы на собеседовании для тестировщика</h2>

<!-- Контейнер для карточек (на десктопе 3 в ряд, на мобильных 2 в ряд) -->
<div class="cards-container">
    <!-- Карточка 1: ТЕОРИЯ ТЕСТИРОВАНИЯ + СОФТЫ -->
    <div class="card" data-topic="theory">
        <div class="card-banner">
            <!-- SVG баннер – здесь можно заменить содержимое на свой SVG -->
            <img src="img/Frame_1.jpg" alt="ТЕОРИЯ ТЕСТИРОВАНИЯ + СОФТЫ" style="width: 100%; height: auto; border-radius: 10px;">
        </div>
        <div class="card-title">
            <h3>ТЕОРИЯ ТЕСТИРОВАНИЯ + СОФТЫ</h3>
        </div>
        <!-- Контент с вопросами – изначально скрыт -->
        <div class="card-questions" style="display: none;">
            <ul>
                <li>
                    <strong>Расскажите про ваше достижение или проект, которым вы гордитесь?</strong>
                    <ul>
                        <li class="node-answer">
                            Расскажите структурировано про ваши пет-проекты, процесс обеспечение качества ПО, взаимодействие со смежными командами и все то, что подчеркивает в вас инициативность и командный дух.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Представьте, что вы не справляетесь с задачей и горит дедлайн. Ваши действия?</strong>
                    <ul>
                        <li class="node-answer">
                            Актуализировать сроки завершения задачи и подсветить риски на дейли, общем собрании. Далее указать причины и все риски (отсутствие аналитики, нехватка тестовых данных, сложность взаимодействия со смежными командами). Обратится за помощью к аналитику, QA лиду, самое главное не ждать у моря погоды и отсиживаться.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Работал ли ты единственным тестировщиком в команде?</strong>
                    <ul>
                        <li class="node-answer">
                            Вопрос задается для проверки самостоятельности в команде. <br><br>Если вы были не единственным тестировщиком, то какую роль выполняли? Тестировщик – прогоняет ручные тесты, но может их не писать самостоятельно.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Тестировали удобства использования?</strong>
                    <ul>
                        <li class="node-answer">
                            Проводили анализ конкурентов (похожих ПО) и есть ли знания принципов UI/UX. <br><br>Можно подсветить коммуникацию с аналитиком и дизайнером
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Занимался исследовательским тестированием?</strong>
                    <ul>
                        <li class="node-answer">
                            Проверка опыта проектирования тестовой документации и использования техник тест-дизайна. <br><br>Пример: в рамках тест-дизайна исследовательское тестирование использовал до погружения в требования и выявления серых зон.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое ad-hoc?</strong>
                    <ul>
                        <li class="node-answer">
                            Ad-hoc тестирование (также – интуитивное или свободное тестирование) – это метод тестирования ПО, проводимый без какого-либо конкретного плана или заранее определенного набора шагов.
                            <br><br>Вместо этого тестировщики используют свою интуицию, опыт и творческий подход для выявления дефектов и проблем, которые не могут обнаружить более формальные методы тестирования.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какие бывают виды требований?</strong>
                    <ul>
                        <li class="node-answer">
                            Требования делятся на прямые и косвенные.<br><br>
                            Прямые - бизнес требования, системные требования, спецификации, макеты приложения, отчеты от заказчика.<br>
                            <br>Косвенные - анализ конкурентов, UX принципы, удобство использования приложения, отчеты бета-тестов.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Бывало такое, что ты не разрешал выпускать фичу в релиз?</strong>
                    <ul>
                        <li class="node-answer">
                            Вопрос на проверку коммуникации как внутри, так и между командами. <br><br>Безусловно были моменты, когда функциональность еще не готова, а сроки релиза не давали возможности закончить тестирование. Я всегда подсвечивал риск обнаружения багов на этапе релиза. <br><br>Agile позволяет исправить ошибку в кратчайшие сроки и здесь самое главное подсветить риск и сообщить как можно раньше.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Как разрешал конфликт с фронтом или бэком?</strong>
                    <ul>
                        <li class="node-answer">
                            Вопрос на проверку умения договорится с дорогими коллегами. <br><br>На моем опыте приходилось работать в команде, где фронт и бэк разработчики не могли договориться и самое главное в общении подключить третью сторону, чтобы не переходить на личности.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Работал без требований? Сталкивался с таким опытом?</strong>
                    <ul>
                        <li class="node-answer">
                            Столкнулся с поиском серых зон еще на курсе "Ромашка", где нам давали неполные спецификации, по которым мы составляли интеллект-карту и матрицу трассировки для проверки покрытия тест-кейсами тестируемое ПО.

                            В команде также сталкивался с отсутсвием актуальных требований, но благодаря опыту знаю как ее восстановить в ближайшее время.<br><br> Спецификация на проекте:<br>

                            1 документация в конфлюенсе;<br>
                            2 макеты фигма;<br>
                            3 задачи в Jira;<br>
                            4 User-Story;<br>
                            5 ТК, ЧЛ;<br>
                            6 запись звонка с владельцем продукта;<br>
                            7 презентация для заказчика;<br>
                            8 корректировки заказчика;<br>

                            <br>Данный список поможет определить серые зоны и актуальность данных.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что делать, если документации нет, а протестировать функционал нужно уже завтра?</strong>
                    <ul>
                        <li class="node-answer">
                            Первое: подсветить риск владельцу продукта, что не успеваешь провести необходимое тестирование.<br><br>

                            Второе: обозначить срок до какого числа ты закончишь с проверкой.<br><br>

                            Если действительно горит выход релиз и риск качества берет на себя ВП, то тестирую по неактуальным требованиям + уточняю работу ПО у аналитика и разраба.<br><br>

                            Ответ подразумевает наличие мягких навыков и твою стрессоустойчивость + (неконфликтность).<br><br>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое тестирование? Цель тестирования?</strong>
                    <ul>
                        <li class="node-answer">
                            Тестирование – процесс сопоставления спецификаций продукта с его финальным результатом. Это не просто поиск багов, а проверка соответствия ожидаемого и фактического результата.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Зачем тестировать ПО? Цель тестирования?</strong>
                    <ul>
                        <li class="node-answer">
                            Для предоставления актуальной информации о состоянии приложения (техническая цель) и повышения доверия пользователей (коммерческая цель).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Почему вначале позитивное, а потом негативное тестирование?</strong>
                    <ul>
                        <li class="node-answer">
                            Сначала убеждаемся в работоспособности функций, а затем пытаемся найти ошибки через негативное тестирование.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Назовите пользу негативных тестов</strong>
                    <ul>
                        <li class="node-answer">
                            Негативное тестирование помогает выявить скрытые дефекты. <br><br>Пример: Телеграм внедрил премиум подписки, но команда при тестировании новых возможностей не учла отмену подписки после оплаты. <br><br>В итоге после отмены подписка оставалась у пользователя, но деньги все же возвращались на карту. Таким образом компания потеряла большую сумму.

                            <br><br>Один из примеров для чего необходимо проводить негативное тестирование, хоть пример можно отнести ближе к функциональному тестированию.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Чем отличаются типы, уровни, методы? Расскажи про каждый атрибут.</strong>
                    <ul>
                        <li class="node-answer">
                            Типы тестирования (например, функциональное, регрессионное) определяют, что проверяется; <br><br>уровни тестирования (модульное, интеграционное, системное, приемочное) описывают этапы проверки; <br><br>методы тестирования (черного, белого, серого ящика) указывают на подходы к проверке. <br><br>Каждый атрибут помогает структурировать процесс тестирования для полного охвата функциональности приложения.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какие уровни тестирования знаете?</strong>
                    <ul>
                        <li class="node-answer">
                            Модульный (компонентный), <br><br>интеграционный, <br><br>системный, <br><br>приёмочный.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Назови церемонии Agile, в которых ты участвовал?</strong>
                    <ul>
                        <li class="node-answer">
                            Планирование спринта, <br><br>Daily, <br><br>PBR (Груминг), <br><br>Ретро, <br><br>Демо (внутреннее и приемка с заказчиком).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Виды/Типы тестирования?</strong>
                    <ul>
                        <li class="node-answer">
                            Функциональное, нефункциональное, тестирование изменений.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Виды интеграционного тестирования?</strong>
                    <ul>
                        <li class="node-answer">
                            Подход «Большого взрыва», нисходящий (сверху вниз), снизу вверх, «сэндвич».
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какие техники тест-дизайна знаете?</strong>
                    <ul>
                        <li class="node-answer">
                            Граничные значения, <br><br>классы эквивалентности, <br><br>таблицы принятия решений, <br><br>причинно-следственная связь, <br><br>попарное тестирование, <br><br>тестирование состояний, <br><br>тестирование сценариев, <br><br>исследовательское тестирование.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Для чего нужна техника попарного тестирования?</strong>
                    <ul>
                        <li class="node-answer">
                            Для сокращения числа тестовых проверок при большом количестве вариантов использования.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Отличие валидации и верификации?</strong>
                    <ul>
                        <li class="node-answer">
                            Верификация подтверждает соответствие требованиям, а валидация – достижение поставленной цели.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Этапы тестирования?</strong>
                    <ul>
                        <li class="node-answer">
                            Планирование, подготовка и выполнение тестов, составление отчёта. <br><br>Подробнее:<br><br>

                            Инициация процесса тестирования.<br><br>
                            Выявление прямых и косвенных требований.<br><br>
                            Генерация тестовых случаев.<br><br>
                            Отбор значимых тестовых случаев.<br><br>
                            Проведение проверок.<br><br>
                            Фиксация результатов.<br><br>
                            Анализ результатов.<br><br>
                            Передача информации о соответствии проверенного продукта требованиям.<br><br>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Тестировали методом черного ящика? Какие методы знаете?</strong>
                    <ul>
                        <li class="node-answer">
                            Метод черного ящика - тестирование ПО без знания его внутренней структуры и реализации. Точнее без необходимости знания внутренней структуры и реализации. QA может знать что под капотом у ПО, но заниматься тестированием от лица пользователя.

                            <br><br>Метод серого ящика - тестирование с некоторым представлением о внутренней структуре ПО.

                            <br><br>Метод белого ящика - тестирование внутренней структуры и реализации ПО.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Назовите основные этапы разработки ПО</strong>
                    <ul>
                        <li class="node-answer">
                            ИДЕЯ - идея зарождается на любом из этапов разработки, но включается в работу вначале каждого спринта. Пример - тестировщик предложил идею как удобнее расположить форму регистрации на этапе тестирования или заказчик внес корректировки в продукт после выката на пром.

                            <br><br>АНАЛИТИКА - системный аналитик начал работу над первичной версией документации к новой фиче. Пример - описание флоу приложения в конфлюенсе. Документация может вносить правки и корректировки даже на этапе разработки, тк приступив к написанию кода могут выясниться технические несостыковки. Это зависи от опыта аналитика и процесса работы в команде. Тестировщик приступает к тест-дизайну на этапе проектирования спецификаций. Не исключение, что QA подключается ещё на этапе идеи.

                            <br><br>РАЗРАБОТКА - фронтенд и бэкенд, в идеале, приступают синхронно (в рамках одного спринта) над реаизацией нового функционала или корректировки старого. Вносятся небольшие изменения в спецификацию продукта. Тестировщик корректирует свои ТК в зависимости от изменений.

                            <br><br>ТЕСТИРОВАНИЕ - в момент передачи разработкой задач на Ready For Test уже подготовлены ТК и ЧЛ для тестирования, остается сама проверка и оформление статуса, результата тестирования.

                            <br><br>ПОДДЕРЖКА (от релиза до прома) - сама поддержка подразумевает сохранение рабочего состояния новой фичи на проме, но в таком случае у нас появляется этап РЕЛИЗ, в данном примере релиз внутри этапа поддержки и с начала переезда на релизный стенд до выката на пром - регрессионное тестирование.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое DOR и DOD?</strong>
                    <ul>
                        <li class="node-answer">
                            DOR (Definition of Ready) – критерии готовности задачи к разработке; <br><br>DOD (Definition of Done) – критерии завершённости задачи.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Знакомо понятие T-shape?</strong>
                    <ul>
                        <li class="node-answer">
                            T-shaped специалист – эксперт в одной области, обладающий базовыми знаниями в других.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какая разница между чек-листом и тест-кейсом?</strong>
                    <ul>
                        <li class="node-answer">
                            Чек-лист — список проверок, а тест-кейс — подробное пошаговое описание пункта из этого списка. На один пункт чек-листа может приходиться несколько тест-кейсов.

                            <br><br>По ТК протестировать ПО может человек с улицы, не имеющий представление об этом ПО, а по ЧЛ протестировать может только специалист, который знаком с ПО.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Назовите атрибуты хорошего тест-кейса</strong>
                    <ul>
                        <li class="node-answer">
                            ID, <br>название, <br>предусловия, <br>шаги, <br>окружение, <br>результаты (логи, скриншоты, файлы).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое баг?</strong>
                    <ul>
                        <li class="node-answer">
                            Баг - это отличие ожидаемого результата ПО от фактического.<br><br>
                            Бывают явные баги, которые содержат статус 4ХХ или UI ошибки, которые не описаны в ожидаемом поведении системы.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какие атрибуты у баг-репорта? Основные поля для заполнения?</strong>
                    <ul>
                        <li class="node-answer">
                            ID, <br>название, <br>описание, <br>приоритет, <br>предусловия, <br>шаги, <br>постусловия, <br>ожидаемый и фактический результат, <br>окружение, <br>приложения (логи, скриншоты).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какая разница между приоритетом и серьезностью?</strong>
                    <ul>
                        <li class="node-answer">
                            Приоритет - это порядок, в котором разработчик должен устранить дефект, тогда как серьезность - это степень влияния дефекта на работу продукта.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Приведите примеры серьезного, но не приоритетного бага</strong>
                    <ul>
                        <li class="node-answer">
                            Более приземленный пример: интернет-магазин прислал красное платье вместо бордового. При разработке макетов цвет кнопок поменяли местам ошибочно. Сервис работает, заказы оформляются, но код цвета не тот. Клиент в ярости.

                            <br><br>Ошибка в соглашении пользователя (ошибка орфографическая или логическая).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое регресс и проверочное тестирование, какая между ними разница?</strong>
                    <ul>
                        <li class="node-answer">
                            Регрессионное тестирование – полная проверка системы после внесения изменений, проверочное – проверка исправления конкретного бага.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое Traceability Matrix?</strong>
                    <ul>
                        <li class="node-answer">
                            Матрица трассировки – таблица, связывающая требования с тестами или другими элементами, позволяющая оценить покрытие тестами.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое «парадокс пестицида»?</strong>
                    <ul>
                        <li class="node-answer">
                            Принцип, согласно которому повторяющиеся тесты со временем теряют эффективность, поэтому их нужно периодически обновлять.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Приведите пример хорошего тест-кейса</strong>
                    <ul>
                        <li class="node-answer">
                            Название, предусловия, шаги, окружение, подтверждение ожидаемого результата.<br><br>
                            Название - Проверить отображение кнопки "Заказать" во вкладке Корзина<br><br>
                            Предусловие - В корзине добавлен товар (Кейс 156) В Jira есть возможность добавить общий шаг (ТК внутри нового ТК)<br><br>
                            Шаг 1 - Войти под пользователем: Admin пароль: 123<br><br>
                            Шаг 2 - Нажать на профиль в правом верхнем углу<br><br>
                            Шаг 3 - В отобразившемся боковом меню нажать "Корзина"<br><br>
                            Шаг 4 - Проверить активное состояние кнопки "Заказать" (при условии если есть товар для заказа
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое нагрузочное тестирование и чем отличается от стресс-тестирования?</strong>
                    <ul>
                        <li class="node-answer">
                            Нагрузочное тестирование оценивает поведение системы под ожидаемой рабочей нагрузкой, измеряя производительность и стабильность. <br><br>Стресс-тестирование проверяет систему за пределами нормальных условий, выявляя пределы отказоустойчивости и восстановление после перегрузок.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какие существуют стандарты UI?</strong>
                    <ul>
                        <li class="node-answer">
                            Принципы KISS, Don't Make Me Think, использование знакомых элементов, упрощение интерфейса и т.д.

                            <br><br>Принцип KISS (Keep It Simple, Stupid) - принцип поддержания простоты, без усложнения.

                            <br><br>Не заставляй меня думать! - не давай лишний повод думать пользователю, когда можно сделать проще.

                            <br><br>Мы удаляем очевидное - не акцентировать внимание на интуитивных действиях.

                            <br><br>Соотношение сигнала и шума - убирать ненужные элементы, чтобы не отвлекать пользователя.

                            <br><br>Лучше рабочее, чем модное - предпочтение функциональности перед модным дизайном.

                            <br><br>Знакомые элементы управления - использование стандартных интерфейсных элементов, которые пользователи уже знают.

                            <br><br>Люди не читают - больше использовать визуальные и интерактивные элементы.

                            <br><br>Принцип заимствования - использование уже существующих решений, которые хорошо работают.

                            <br><br>Бумажник Миллера - ограничение количества элементов в одном функциональном блоке до 5-7.

                            <br><br>Принцип группировки - разделение информации на части и дозирование ее представления.

                            <br><br>Интуитивная ясность - кнопки и разделы должны быть легко обнаруживаемыми и понятными.

                            <br><br>Все полезно на виду - важные элементы интерфейса должны быть видны и выделены.

                            <br><br>Принцип 3 клика - пользователь должен достичь нужной информации или раздела не более чем за 3 клика.

                            <br><br>Однородность - использование единого стиля во всем продукте.

                            <br><br>Способ решения проблемы - продукт должен решать проблемы пользователей, а не создавать новые.

                            <br><br>Защита от случайных действий - предотвращение случайного удаления, заказа, пересылки или отправки.

                            <br><br>Принцип единства - предоставление возможности управления настройками и элементами управления из одного места, если это необходимо.

                            <br><br>Тенденции - учет современных тенденций, чтобы интерфейс не устарел до выхода проекта и соответствовал его целям.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Вопросы на софты без конкретного ответа</strong>
                    <ul>
                        <li class="node-answer">
                            Какая ваша самая сильная/слабая сторона?<br><br>
                            Как вы справляетесь с критикой?<br><br>
                            Что бы вы хотели улучшить в себе?<br><br>
                            Что вы делаете, если вам не хватает ресурсов для задачи?<br><br>
                            Как вы приоритизируете задачи?<br><br>
                            Как вы отреагируете на просьюу поработать на выходных?<br><br>
                            Как вы справляетесь с многозадачностью?<br><br>
                            Как вы справляетесь с трудными коллегами?<br><br>
                            Что для вас важно в руководителе?<br><br>
                            Как вы делитесь знаниями с командой?<br><br>
                            Какие роли вы предпочитаете в проекте?<br><br>
                            Как вы даете обратную связь?<br><br>
                            Как вы убеждаете команду принять ваше предложение?<br><br>
                            Какие задачи вас мотивируют?<br><br>
                            Как вы справляетесь с рутиной?<br><br>
                            Какие проекты вас вдохновляют?<br><br>
                            Что вам нравится больше: работать индивидуально или в команде?<br><br>
                            Какие навыки вы хотите развить?<br><br>
                            Как вы реагируете на неудачи?<br><br>
                            Что вы цените больше всего в работе?<br><br>
                            Почему вы ушли с предыдущего места работы?<br><br>
                            Как вы учились новым навыкам на прошлой работе?<br><br>
                            Какие у вас планы на профессиональное развитие?<br><br>
                            Что вам нравится больше: фронтенд или бэкенд?<br><br>
                            Какие книги/тг каналы по IT вы читали недавно?<br><br>
                            Как вы развиваете свои софт-скиллы?<br><br>
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <!-- Карточка 2: WEB -->
    <div class="card" data-topic="web">
        <div class="card-banner">
            <div class="card-banner">
                <!-- SVG баннер – здесь можно заменить содержимое на свой SVG -->
                <img src="img/Frame_2.jpg" alt="ТЕОРИЯ ТЕСТИРОВАНИЯ + СОФТЫ" style="width: 100%; height: auto; border-radius: 10px;">
            </div>
        </div>
        <div class="card-title">
            <h3>WEB</h3>
        </div>
        <div class="card-questions" style="display: none;">
            <ul>
                <li>
                    <strong>Что такое браузер?</strong>
                    <ul>
                        <li class="node-answer">
                            Браузер – программа для просмотра веб-страниц, которая преобразует полученный код в визуальные элементы. <br><br>Технический ответ: Браузер выступает в качестве клиента в клиент-серверной архитектуре.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какие движки браузеров ты знаешь? Зачем это знать QA?</strong>
                    <ul>
                        <li class="node-answer">
                            Движок браузера — это программа, которая преобразует код веб-страницы (HTML, CSS, JavaScript и т. д.) в интерактивное изображение, которое мы видим на экране.<br><br>

                            Из-за движка браузера некоторые анимации и элементы веб-страницы могут не поддерживаться или отображаться иначе.<br><br>

                            • Blink —  Google Chrome, Microsoft Edge, Opera.<br><br>
                            • WebKit —  Safari и другими браузерами на основе Chromium.<br><br>
                            • Gecko —  Firefox и другими продуктами Mozilla.<br><br>
                            • Trident —  Internet Explorer до версии 11.<br><br>
                            • EdgeHTML —  Microsoft Edge до версии 79.<br><br>
                            • Chromium —  Microsoft Edge, Brave.<br><br>

                            Знание движков и различие между браузерами позволяет ориентироваться в кросс-браузерном тестировании и для чего оно проводится.
                            (Отображение веб-сервиса на разных браузерах, а также проверка основного функционала).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что происходит, когда мы вводим в строку браузера github.com?</strong>
                    <ul>
                        <li class="node-answer">
                            Если мы уже посещали данный сайт, то в кэше браузера хранится IP-адрес сайта. Это можно заметить, когда вводишь первые буквы и появляется подсказка.<br><br>

                            Если сайт не был посещен ранее, браузер связывается с DNS-сервером, который ищет IP-адрес сайта. После получения IP-адреса по нему запрашивается код страницы.<br><br>

                            В данном случае github.com - это как имя контакта "Суши" в вашем телефоне, а IP-адрес - это номер телефона. Когда вы вводите "Суши", телефон показывает номер, чтобы совершить звонок. Так же, когда вы вводите github.com, DNS определяет IP-адрес, чтобы браузер мог загрузить страницу.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое HTML/CSS/JavaScript?</strong>
                    <ul>
                        <li class="node-answer">
                            HTML, CSS и JavaScript — это как три стихии: Вода, Огонь и Воздух. Каждый из них отвечает за свою функцию.<br><br>

                            HTML отвечает за разметку элементов на сайте. (DOM страницы).<br><br>

                            CSS отвечает за стилизацию элементов (внешний вид).<br><br>

                            JavaScript отвечает за действия и интерактивность на странице (анимации, обработка событий).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какие вкладки браузера Chrome отвечают за работу с HTML/CSS/JavaScript?</strong>
                    <ul>
                        <li class="node-answer">
                            В браузере Google Chrome для работы с HTML, CSS и JavaScript<br>
                            в основном используются следующие вкладки в панели разработчика (DevTools):<br><br>

                            1. Elements:<br>
                            - Здесь можно просмотреть и изменить HTML-разметку страницы.<br>
                            - Можно также изменять и просматривать примененные CSS-стили.<br><br>

                            2. Sources:<br>
                            - В этой вкладке можно просматривать и отлаживать JavaScript-код.<br>
                            - Можно ставить точки останова, отслеживать выполнение кода и анализировать скрипты.<br><br>

                            3. Console:<br>
                            - Позволяет выполнять JavaScript-код в реальном времени и выводить различные данные для диагностики.<br>
                            - Полезна для просмотра ошибок и логов во время выполнения скриптов.<br><br>

                            4. Network:<br>
                            - Отслеживает запросы и загрузку различных ресурсов, таких как HTML, CSS и JavaScript файлы.<br>
                            - Полезна для анализа производительности и решения проблем с сетевыми запросами.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое клиент-серверная архитектура?</strong>
                    <ul>
                        <li class="node-answer">
                            Клиент-серверная архитектура — это архитектурный стиль, при котором идет взаимодействие клиента (например, браузера) и сервера посредством передачи данных.<br><br>

                            Клиент отправляет запрос на сервер, который может взаимодействовать с базой данных для сохранения, изменения или чтения информации.<br><br>

                            Основные роли:<br><br>

                            • Клиент: отправляет запросы и отображает информацию пользователю.<br><br>

                            • Балансировщик нагрузки (Load Balancer): распределяет входящие запросы между несколькими серверами для оптимизации нагрузки.<br><br>

                            • Сервер: обрабатывает запросы клиентов и взаимодействует с базой данных.<br><br>

                            • База данных (БД): хранит данные и отвечает на запросы сервера.<br><br>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какие бывают виды клиент-серверной архитектуры?</strong>
                    <ul>
                        <li class="node-answer">
                            Одноуровневая (1-tier):<br>
                            Клиент и сервер расположены на одном устройстве. Примеры: Приложение для работы в оффлайн-режиме с локальными данными.<br><br>

                            Двухуровневая (2-tier):<br>
                            Клиент и сервер разделены, клиент взаимодействует с сервером напрямую. Примеры: Приложения, требующие прямого доступа к базе данных через сеть.<br><br>

                            Трехуровневая (3-tier):<br>
                            Включает три уровня: клиент, приложение (аппликейшн) сервер, и сервер базы данных. Веб-приложения, где клиент обращается к веб-серверу, который в свою очередь взаимодействует с базой данных.<br><br>

                            Многоуровневая (n-tier):<br>
                            Состоит из нескольких уровней, обеспечивающих дополнительную гибкость и масштабируемость. Уровни могут включать веб-серверы, серверы приложений, базы данных и другие сервисные уровни. Сложные корпоративные приложения, требующие высокой масштабируемости и производительности.<br><br>

                            Peer-to-Peer (P2P):<br>
                            Каждый узел может выступать в роли клиента и сервера одновременно. Системы для обмена файлами, криптовалюты.

                            Микросервисная архитектура:<br>
                            Приложение разрабатывается как набор небольших, независимых сервисов, каждый из которых выполняет одну четко определенную функцию и взаимодействует с другими службами через API. Современные веб-приложения, требующие высокой гибкости и возможностей для частого обновления.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что может выступать в качестве клиента?</strong>
                    <ul>
                        <li class="node-answer">
                            Браузеры, нативные и гибридные приложения, веб-приложения, командная строка.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое протокол передачи данных? Назови основные протоколы</strong>
                    <ul>
                        <li class="node-answer">
                            Сетевой протокол — это набор правил, определяющих принципы взаимодействия устройств в сети (клиента и сервера).<br><br>

                            Основной протокол HTTP — это незащищенный протокол. Его часто можно встретить на сайтах с тестами на характер. Например, если результат теста можно отправить другому человеку, просто переслав ему ссылку, это указывает на использование HTTP. Рядом с доменом сайта обычно нет значка "замочка".<br><br>

                            HTTPS — это защищенная версия HTTP, обеспечивающая шифрование данных для безопасного взаимодействия в сети. Самый популрный защищенный протокол.<br><br>

                            Основные: HTTPS, FTP, SMTP, DNS, NTP.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое микросервисы? Расскажите про микросервисную архитектуру?</strong>
                    <ul>
                        <li class="node-answer">
                            Микросервисная архитектура — это способ построения приложений, которые состоят из независимых друг от друга небольших модулей.<br><br>

                            Подход к тестированию микросервисной архитектуры отличается от всем привычного. Она представляет собой совокупность мелких сервисов, каждый из которых отвечает за определенный функционал,
                            а вместе они представляют собой готовое приложение и решают определенную глобальную задачу.<br><br>

                            Главным преимуществом и одновременно трудностью тестирования является то, что они располагаются на различных серверах и написаны на разных языках программирования, таких как Java и .Net.
                            Фактически разработчики определённого микросервиса не знают, что делают остальные микросервисы, что усложняет процесс тестирования. Но зато мы можем быстро обновить и протестировать отдельный микросервис, не затронув другие.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Работал с инструментом разработчика? DevTools</strong>
                    <ul>
                        <li class="node-answer">
                            Использовал DevTools для отладки кода, анализа DOM, отслеживания сетевых запросов (их логирование) и оптимизации производительности.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Где мы можем смотреть ответы от сервера?</strong>
                    <ul>
                        <li class="node-answer">
                            Ответы от сервера можно наблюдать на вкладке Network в DevTools, где отображаются запросы, статусы и данные ответов.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Как мы можем скопировать текст со страницы в DevTools?</strong>
                    <ul>
                        <li class="node-answer">
                            В панели Elements можно выбрать элемент, правой кнопкой мыши выбрать "Copy → Copy element" или "Edit as HTML", чтобы скопировать текст.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Назови основные вкладки DevTools и чем они будут тебе полезны?</strong>
                    <ul>
                        <li class="node-answer">
                            Основные вкладки: Elements (DOM и стили), Console (вывод ошибок и логирование), Network (мониторинг HTTP-запросов), Sources (отладка кода), Performance (анализ производительности), Application (работа с кэшем и куки).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Где можно эмулировать состояние сети в DevTools?</strong>
                    <ul>
                        <li class="node-answer">
                            Вкладка Network позволяет эмулировать различные скорости сети через настройки Throttling.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое куки и кэш?</strong>
                    <ul>
                        <li class="node-answer">
                            Куки – данные, сохраняемые браузером для идентификации сессии; кэш – временное хранение ресурсов сайта для ускорения загрузки страниц.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Как очистить кэш браузера?</strong>
                    <ul>
                        <li class="node-answer">
                            Кэш можно очистить через настройки браузера или через DevTools (вкладка Application), а также с помощью сочетания клавиш (например, Ctrl+Shift+Delete).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое cURL? Для чего используют?</strong>
                    <ul>
                        <li class="node-answer">
                            cURL – командная утилита для передачи данных с использованием URL-синтаксиса, применяемая для отправки HTTP-запросов и отладки API.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое User Agent? Какие данные содержит?</strong>
                    <ul>
                        <li class="node-answer">
                            User Agent – строка, описывающая браузер, его версию, операционную систему и устройство, отправляемая в HTTP-заголовках для идентификации клиента.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое сниффер? Для чего предназначен в тестировании?</strong>
                    <ul>
                        <li class="node-answer">
                            Сниффер – инструмент для перехвата и анализа сетевого трафика, используемый для диагностики, отладки и проверки безопасности передачи данных.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какие виды локаторов страницы есть? Каковы их преимущества и недостатки?</strong>
                    <ul>
                        <li class="node-answer">
                            Локаторы: ID (быстрый и уникальный), name, class, CSS (легковесные и гибкие), XPath (гибкий, позволяет навигацию по DOM, но медленнее) и link text (для ссылок, зависящий от текста).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Отличие css от xpath?</strong>
                    <ul>
                        <li class="node-answer">
                            CSS локаторы проще и быстрее, но не поддерживают сложную иерархическую навигацию, в отличие от XPath, который позволяет детальный поиск в DOM, хотя может работать медленнее.
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <!-- Карточка 3: API -->
    <div class="card" data-topic="api">
        <div class="card-banner">
            <div class="card-banner">
                <!-- SVG баннер – здесь можно заменить содержимое на свой SVG -->
                <img src="img/Frame_3.jpg" alt="ТЕОРИЯ ТЕСТИРОВАНИЯ + СОФТЫ" style="width: 100%; height: auto; border-radius: 10px;">
            </div>
        </div>
        <div class="card-title">
            <h3>API</h3>
        </div>
        <div class="card-questions" style="display: none;">
            <ul>
                <li>
                    <strong>Что такое API?</strong>
                    <ul>
                        <li class="node-answer">
                            API (Application Programming Interface) – набор протоколов и инструментов для создания программ, который определяет, как программные компоненты взаимодействуют друг с другом.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Из чего состоит URL?</strong>
                    <ul>
                        <li class="node-answer">
                            URL состоит из схемы (например, http/https), домена, порта (опционально), пути, параметров запроса и фрагмента (якоря).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое REST/RestFull</strong>
                    <ul>
                        <li class="node-answer">
                            REST – архитектурный стиль для разработки веб-сервисов, использующий стандартные методы HTTP. RESTful сервисы придерживаются этих принципов для обеспечения масштабируемости и простоты интеграции.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Отличия REST от SOAP?</strong>
                    <ul>
                        <li class="node-answer">
                            REST – легковесный, использующий HTTP и часто JSON; SOAP – протокол с формальной спецификацией, использующий XML и требующий дополнительных контрактов (WSDL).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какой формат передачи информации используется в SOAP, а какой в REST?</strong>
                    <ul>
                        <li class="node-answer">
                            SOAP использует XML для обмена сообщениями, а REST чаще всего использует JSON, хотя может работать и с XML.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Назови основные методы REST</strong>
                    <ul>
                        <li class="node-answer">
                            GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD – методы, соответствующие операциям с ресурсами.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какая разница между методами GET и POST?</strong>
                    <ul>
                        <li class="node-answer">
                            GET используется для получения данных и не изменяет состояние сервера, а POST отправляет данные, часто изменяя состояние сервера, при этом данные передаются в теле запроса.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какие отличия между XML и JSON?</strong>
                    <ul>
                        <li class="node-answer">
                            XML – разметочный язык с тегами и атрибутами, более формальный и гибкий; JSON – компактный, легкий для чтения и парсинга, предпочтительный для веб-сервисов.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Назови статусы ответов</strong>
                    <ul>
                        <li class="node-answer">
                            Статусы делятся на классы: 1xx (информационные), 2xx (успешные, например, 200 OK), 3xx (перенаправления), 4xx (ошибки клиента, например, 404 Not Found) и 5xx (ошибки сервера, например, 500 Internal Server Error).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Где смотреть статусы ответов?</strong>
                    <ul>
                        <li class="node-answer">
                            Статусы ответов можно увидеть во вкладке Network в DevTools, а также в логах сервера или в инструментах для тестирования API, таких как Postman.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Опишите каждый класс ответов Сотые, двухсотые и т.д.</strong>
                    <ul>
                        <li class="node-answer">
                            1xx – информационные, 2xx – успешные, 3xx – перенаправления, 4xx – ошибки клиента, 5xx – ошибки сервера. Каждый класс указывает на характер ответа и дальнейшие действия клиента.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое http?</strong>
                    <ul>
                        <li class="node-answer">
                            HTTP (Hypertext Transfer Protocol) – протокол передачи данных между клиентом и сервером, используемый в сети Интернет.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Основные методы HTTP:</strong>
                    <ul>
                        <li class="node-answer">
                            GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD – определяют тип операции, которую клиент может выполнить над ресурсами.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое Postman/Insomnia?</strong>
                    <ul>
                        <li class="node-answer">
                            Postman и Insomnia – инструменты для тестирования API, позволяющие отправлять HTTP-запросы, просматривать ответы и автоматизировать тестовые сценарии.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое коллекция?</strong>
                    <ul>
                        <li class="node-answer">
                            Коллекция – набор сохранённых запросов и тестов, сгруппированных по проекту или функциональности для удобства повторного использования.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Как расшифровывается CRUD?</strong>
                    <ul>
                        <li class="node-answer">
                            CRUD – Create, Read, Update, Delete – базовые операции для работы с данными.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое глобальная переменная?</strong>
                    <ul>
                        <li class="node-answer">
                            Глобальная переменная – переменная, доступная во всех запросах коллекции, используемая для хранения общих данных, например, токенов.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое переменная окружения?</strong>
                    <ul>
                        <li class="node-answer">
                            Переменная окружения – набор параметров, определяющих настройки для конкретной среды (dev, test, prod), позволяющий менять конфигурацию без изменения самих запросов.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что нельзя положить в коллекцию?</strong>
                    <ul>
                        <li class="node-answer">
                            Не рекомендуется включать в коллекцию конфиденциальные данные (например, пароли, секретные ключи) или нестабильные, временные значения, способные нарушить повторяемость тестов.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>На каком языке пишутся API автотесты?</strong>
                    <ul>
                        <li class="node-answer">
                            API автотесты могут писаться на Java, Python, JavaScript, C# – выбор зависит от используемого фреймворка и инфраструктуры проекта.
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <!-- Карточка 4: БАЗЫ ДАННЫХ -->
    <div class="card" data-topic="databases">
        <div class="card-banner">
            <div class="card-banner">
                <!-- SVG баннер – здесь можно заменить содержимое на свой SVG -->
                <img src="img/Frame_4.jpg" alt="БАЗЫ ДАННЫХ" style="width: 100%; height: auto; border-radius: 10px;">
            </div>
        </div>
        <div class="card-title">
            <h3>БАЗЫ ДАННЫХ</h3>
        </div>
        <div class="card-questions" style="display: none;">
            <ul>
                <li>
                    <strong>Что такое БД?</strong>
                    <ul>
                        <li class="node-answer">
                            База данных (БД) – систематизированное хранилище данных, управляемое СУБД, которое обеспечивает хранение, поиск и модификацию информации.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Типы БД</strong>
                    <ul>
                        <li class="node-answer">
                            Основные типы:<br><br>
                            реляционные (MySQL, PostgreSQL, Oracle Database, Microsoft SQL Server, SQLite)<br>
                            документо-ориентированные (MongoDB, CouchDB, Amazon DocumentDB)<br>
                            ключ-значение (Redis, Amazon DynamoDB)<br>
                            графовые базы данных (ArangoDB, OrientDB)<br>
                            колонно-ориентированные БД (Apache Cassandra, ClickHouse, Amazon Redshift)<br>
                            объектно-ориентированные БД (ObjectDB)<br>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Отличие реляционных от нереляционных БД?</strong>
                    <ul>
                        <li class="node-answer">
                            Реляционные БД используют таблицы с фиксированной схемой и SQL для запросов, тогда как нереляционные БД гибче, масштабируются горизонтально и используют различные модели данных.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Назови структуру запроса в БД (SELECT FROM WHERE ORDER BY GROUP BY)</strong>
                    <ul>
                        <li class="node-answer">
                            SELECT - Определяет, какие столбцы или выражения извлекаются<br>
                            DISTINCT - Убирает повторяющиеся строки из результатов<br>
                            FROM - Указывает таблицу(ы) или подзапрос, откуда берутся данные<br>
                            JOIN - Объединяет данные из нескольких таблиц<br>
                            WHERE - Фильтрует строки до группировки<br>
                            GROUP BY - Группирует строки по значениям одного или нескольких столбцов<br>
                            HAVING - Фильтрует группы после группировки<br>
                            UNION / INTERSECT/ EXCEPT - Оперирует над результатами нескольких запросов<br>
                            ORDER BY - Сортирует результат по одному или нескольким столбцам<br>
                            LIMIT - Ограничивает количество возвращаемых строк<br>
                            OFFSET - Пропускает указанное количество строк в выводе<br><br>

                            Пример:<br><br>

                            SELECT DISTINCT department, COUNT(*) AS total<br>
                            FROM employees<br>
                            JOIN departments ON employees.dept_id = departments.id<br>
                            WHERE salary > 50000<br>
                            GROUP BY department<br>
                            HAVING COUNT(*) > 3<br>
                            ORDER BY total DESC<br>
                            LIMIT 10 OFFSET 5;<br>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Типы JOIN? (показать на кругах Эйлера)</strong>
                    <ul>
                        <li class="node-answer">
                            Основные типы JOIN: INNER JOIN, LEFT (OUTER) JOIN, RIGHT (OUTER) JOIN, FULL (OUTER) JOIN и CROSS JOIN – используются для объединения строк из разных таблиц по общему полю.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Для чего используем Order By/Group By?</strong>
                    <ul>
                        <li class="node-answer">
                            ORDER BY используется для сортировки результатов, а GROUP BY – для агрегирования данных по определённому критерию с последующим применением агрегатных функций.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какая разница между DROP, TRUNCATE и DELETE?</strong>
                    <ul>
                        <li class="node-answer">
                            DROP удаляет таблицу вместе со структурой.<br>
                            Пример: DROP TABLE employees;<br><br>
                            TRUNCATE удаляет все записи, сохраняя структуру таблицы.<br>
                            Пример: TRUNCATE TABLE employees;<br><br>
                            DELETE удаляет строки из таблицы (можно использовать WHERE).<br>
                            Пример: DELETE FROM employees WHERE department = 'Sales';
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Назови порядок выполнения SELECT-запроса</strong>
                    <ul>
                        <li class="node-answer">
                            1.	FROM — выбор таблицы или таблиц (и JOIN’ы, если есть)<br>
                            2.	WHERE — фильтрация строк<br>
                            3.	GROUP BY — группировка строк<br>
                            4.	HAVING — фильтрация групп (после группировки)<br>
                            5.	SELECT — выбор нужных столбцов и выражений<br>
                            6.	DISTINCT — удаление дубликатов (если есть)<br>
                            7.	ORDER BY — сортировка результата<br>
                            8.	LIMIT / OFFSET — ограничение количества строк<br><br>
                            Пример:<br><br>
                            SELECT department, COUNT(*) AS total_employees<br>
                            FROM employees<br>
                            WHERE salary > 50000<br>
                            GROUP BY department<br>
                            HAVING COUNT(*) > 5<br>
                            ORDER BY total_employees DESC<br>
                            LIMIT 10;<br>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Выведи из таблицы Product пять продуктов, у которых price выше 1000</strong>
                    <ul>
                        <li class="node-answer">
                            SELECT *<br>
                            FROM Product<br>
                            WHERE price > 1000<br>
                            ORDER BY price DESC<br>
                            LIMIT 5;<br>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Как объединить 2 таблицы?</strong>
                    <ul>
                        <li class="node-answer">
                            1. INNER JOIN — внутреннее соединение:<br>
                            Выбирает только совпадающие строки из обеих таблиц по условию.<br><br>

                            SELECT *<br>
                            FROM table1<br>
                            INNER JOIN table2<br>
                            ON table1.id = table2.id;<br><br>

                            2. LEFT JOIN (или LEFT OUTER JOIN):<br>
                            Берёт все строки из левой таблицы, и только совпадающие — из правой. Если в правой нет соответствия — подставляется NULL.<br><br>

                            SELECT *<br>
                            FROM table1<br>
                            LEFT JOIN table2<br>
                            ON table1.id = table2.id;<br><br>

                            3. RIGHT JOIN (или RIGHT OUTER JOIN):<br>
                            То же самое, но наоборот: все строки из правой таблицы, и только совпадающие — из левой.<br><br>

                            SELECT *<br>
                            FROM table1<br>
                            RIGHT JOIN table2<br>
                            ON table1.id = table2.id;<br><br>

                            4. FULL JOIN (или FULL OUTER JOIN):<br>
                            Возвращает все строки из обеих таблиц. Там, где нет совпадений, подставляется NULL.<br><br>

                            SELECT *<br>
                            FROM table1<br>
                            FULL JOIN table2<br>
                            ON table1.id = table2.id;<br>


                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое оконная функция?</strong>
                    <ul>
                        <li class="node-answer">
                            Оконная функция в SQL выполняет вычисления по набору строк, связанных с текущей строкой, без группировки, позволяя получать, например, ранжирование или суммарные значения по разделам.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое подзапросы?</strong>
                    <ul>
                        <li class="node-answer">
                            Подзапрос – это запрос, вложенный в другой запрос, используемый для вычисления значений или фильтрации данных.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Для чего используют агрегатные функции?</strong>
                    <ul>
                        <li class="node-answer">
                            Агрегатные функции (SUM, COUNT, AVG, MIN, MAX) используются для вычисления сводных значений по набору строк.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Приведи пример запроса на вычисление среднего значения стоимости в столбце Price</strong>
                    <ul>
                        <li class="node-answer">
                            Пример: <code>SELECT AVG(Price) AS AvgPrice FROM Products;</code>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какими способами мы можем подключиться к БД?</strong>
                    <ul>
                        <li class="node-answer">
                            Подключение возможно через клиентские приложения (например, pgAdmin, SQL Developer), драйверы для языков программирования (JDBC, ODBC), командную строку или ORM фреймворки.
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <!-- Карточка 5: GIT + IDE + SELENIUM -->
    <div class="card" data-topic="git">
        <div class="card-banner">
            <div class="card-banner">
                <!-- SVG баннер – здесь можно заменить содержимое на свой SVG -->
                <img src="img/Frame_5.jpg" alt="ТЕОРИЯ ТЕСТИРОВАНИЯ + СОФТЫ" style="width: 100%; height: auto; border-radius: 10px;">
            </div>
        </div>
        <div class="card-title">
            <h3>GIT + IDE + SELENIUM</h3>
        </div>
        <div class="card-questions" style="display: none;">
            <ul>
                <li>
                    <strong>Что такое GIT?</strong>
                    <ul>
                        <li class="node-answer">
                            Git – распределённая система контроля версий, позволяющая отслеживать изменения в коде, работать с ветками и объединять изменения от разных разработчиков.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Основные команды GIT</strong>
                    <ul>
                        <li class="node-answer">
                            Основные команды: <code>git init</code>, <code>git clone</code>, <code>git add</code>, <code>git commit</code>, <code>git push</code>, <code>git pull</code>, <code>git branch</code>, <code>git merge</code>, <code>git checkout</code>, <code>git status</code>, <code>git log</code>.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>С какими клиентами GIT работал?</strong>
                    <ul>
                        <li class="node-answer">
                            Работал с Git CLI, GitHub Desktop, SourceTree, GitKraken, а также с интегрированными системами в IDE, такими как IntelliJ IDEA и Visual Studio Code.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое репозиторий?</strong>
                    <ul>
                        <li class="node-answer">
                            Репозиторий – хранилище проекта, содержащее файлы, историю изменений и метаданные, доступное локально и/или удалённо.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое commits, branches в Git?</strong>
                    <ul>
                        <li class="node-answer">
                            Commit – зафиксированное изменение с сообщением; branch – отдельная линия разработки, позволяющая работать над фичами независимо от основной ветки.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое Pull request?</strong>
                    <ul>
                        <li class="node-answer">
                            Pull request – запрос на слияние ветки с основной, сопровождаемый обсуждением изменений и код-ревью.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Каким способом можно клонировать репозиторий?</strong>
                    <ul>
                        <li class="node-answer">
                            Клонирование производится командой <code>git clone</code> с URL репозитория, создавая локальную копию.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое ООП? Назовите его принципы с примерами?</strong>
                    <ul>
                        <li class="node-answer">
                            ООП (Объектно-Ориентированное Программирование) основывается на принципах инкапсуляции, наследования, полиморфизма и абстракции, позволяющих структурировать код с помощью классов и объектов.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое SOLID? Приведите примеры</strong>
                    <ul>
                        <li class="node-answer">
                            SOLID – набор принципов разработки: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion. Эти принципы помогают создавать расширяемый и поддерживаемый код.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое DRY, KISS, YAGNI?</strong>
                    <ul>
                        <li class="node-answer">
                            DRY (Don't Repeat Yourself) – избегать дублирования кода; KISS (Keep It Simple, Stupid) – сохранять простоту; YAGNI (You Aren't Gonna Need It) – не реализовывать функциональность заранее.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое Selenium?</strong>
                    <ul>
                        <li class="node-answer">
                            Selenium – фреймворк для автоматизации тестирования веб-приложений, позволяющий управлять браузерами через WebDriver.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое WebDriver?</strong>
                    <ul>
                        <li class="node-answer">
                            WebDriver – интерфейс API в Selenium, обеспечивающий взаимодействие с браузером для имитации действий пользователя.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Зачем нужны TestNG/JUnit?</strong>
                    <ul>
                        <li class="node-answer">
                            TestNG и JUnit – тестовые фреймворки для Java, позволяющие структурировать, выполнять и отчитываться о тестах с использованием аннотаций и ассертов.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое assertions?</strong>
                    <ul>
                        <li class="node-answer">
                            Assertions – проверки, сравнивающие ожидаемый результат с фактическим, сигнализирующие об ошибке при несоответствии.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое Selenium Waits? Какие есть и чем отличаются?</strong>
                    <ul>
                        <li class="node-answer">
                            Selenium Waits – механизмы ожидания для синхронизации тестов. Неявные ожидания устанавливают глобальный таймаут, а явные позволяют ожидать конкретное условие для элемента.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое CI/CD?</strong>
                    <ul>
                        <li class="node-answer">
                            CI/CD (Continuous Integration/Continuous Deployment) – практика автоматизации сборки, тестирования и развертывания кода для быстрого и стабильного релиза.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое Jenkins?</strong>
                    <ul>
                        <li class="node-answer">
                            Jenkins – сервер автоматизации, используемый для настройки CI/CD pipeline, сборки, тестирования и деплоя проектов.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Как настроить Job или Pipeline на знакомом вам CI-инструменте?</strong>
                    <ul>
                        <li class="node-answer">
                            Настройка включает создание конфигурационного файла (например, Jenkinsfile) с шагами сборки, тестирования и деплоя, а также настройку триггеров для автоматического запуска при изменениях в репозитории.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>С какими IDE работали?</strong>
                    <ul>
                        <li class="node-answer">
                            Работал с IntelliJ IDEA, Eclipse, Visual Studio Code, PyCharm – выбор зависит от стека технологий.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое Maven?</strong>
                    <ul>
                        <li class="node-answer">
                            Maven – инструмент для управления проектами на Java, обеспечивающий сборку, управление зависимостями и стандартизированную структуру проекта через POM-файл.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Что такое PageObject и PageFactory?</strong>
                    <ul>
                        <li class="node-answer">
                            PageObject – паттерн для организации автотестов, где каждая страница представлена классом с методами взаимодействия. PageFactory – инструмент для инициализации элементов страницы, упрощающий работу с локаторами.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Какая разница между String, Stringbuffer и Stringbuilder?</strong>
                    <ul>
                        <li class="node-answer">
                            String – неизменяемая строка; StringBuffer – изменяемая строка с синхронизацией (потокобезопасная); StringBuilder – изменяемая строка без синхронизации (быстрее в однопоточной среде).
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <!-- Карточка 6: DEVOPS -->
    <div class="card" data-topic="devops">
        <div class="card-banner">
            <div class="card-banner">
                <!-- SVG баннер – здесь можно заменить содержимое на свой SVG -->
                <img src="img/Frame_6.jpg" alt="ТЕОРИЯ ТЕСТИРОВАНИЯ + СОФТЫ" style="width: 100%; height: auto; border-radius: 10px;">
            </div>
        </div>
        <div class="card-title">
            <h3>DEVOPS</h3>
        </div>
        <div class="card-questions" style="display: none;">
            <ul>
                <li>
                    <strong>Что такое Docker?</strong>
                    <ul>
                        <li class="node-answer">
                            Docker – платформа для контейнеризации, позволяющая создавать, развёртывать и запускать приложения в изолированных контейнерах.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Отличие виртуальных машин от контейнеров?</strong>
                    <ul>
                        <li class="node-answer">
                            Виртуальные машины запускают полные операционные системы, контейнеры используют ядро хоста.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Расскажите, как проходил релиз в вашей команде?</strong>
                    <ul>
                        <li class="node-answer">
                            Релиз осуществлялся через CI/CD pipeline с автоматической сборкой, тестированием и деплоем.
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

</div>

<footer class="qatodev">
    <p><a href="https://t.me/QAtoDev" target="_blank">Telegram-канал QAtoDev</a></p>
</footer>
<!-- / .cards-container -->

<!-- Скрипты: обработка клика по карточкам и переключение видимости ответов -->
<script>
    document.querySelectorAll('.card-questions li strong').forEach(function(el) {
  el.addEventListener('dblclick', function(e) {
    // Отменяем стандартное поведение
    e.preventDefault();
    // Сбрасываем выделение текста
    if (window.getSelection) {
      window.getSelection().removeAllRanges();
    } else if (document.selection) {
      document.selection.empty();
    }
  });
});
    document.addEventListener('DOMContentLoaded', function () {
      // Бургер-меню
      const burgerMenu = document.querySelector('.burger-menu');
      const navLinks = document.querySelector('nav ul');
      burgerMenu.addEventListener('click', () => {
        navLinks.classList.toggle('active');
      });

      // Обработка клика по изображению (баннеру) внутри карточки
      const cards = document.querySelectorAll('.card');
      cards.forEach(card => {
        const banner = card.querySelector('.card-banner');
        if (banner) {
          banner.addEventListener('click', function (e) {
            // Предотвращаем всплытие, чтобы не срабатывали другие обработчики
            e.stopPropagation();
            const questions = card.querySelector('.card-questions');
            if (!card.classList.contains('expanded')) {
              card.classList.add('expanded');
              if (questions) {
                questions.style.display = 'block';
              }
            } else {
              card.classList.remove('expanded');
              if (questions) {
                questions.style.display = 'none';
              }
            }
          });
        }
      });

  // Функция для переключения отображения ответа
  function toggleAnswer(nestedUl, toggleBtn) {
    if (nestedUl.style.display === 'none') {
      nestedUl.style.display = 'block';
      toggleBtn.textContent = '–';
    } else {
      nestedUl.style.display = 'none';
      toggleBtn.textContent = '+';
    }
  }

  // Добавляем кнопки переключения для раскрытия/сокрытия ответа внутри вопросов
  const allListItems = document.querySelectorAll('.card-questions li');
  allListItems.forEach(li => {
    const nestedUl = li.querySelector('ul');
    if (nestedUl && nestedUl.querySelector('.node-answer')) {
      nestedUl.style.display = 'none';

      // Создаём кнопку переключения
      const toggleBtn = document.createElement('button');
      toggleBtn.classList.add('toggle-btn');
      toggleBtn.textContent = '+';

      // Обработчик клика по кнопке
      toggleBtn.addEventListener('click', function (e) {
        e.stopPropagation();
        toggleAnswer(nestedUl, toggleBtn);
      });

      // Вставляем кнопку перед первым элементом списка
      li.insertBefore(toggleBtn, li.firstElementChild);

      // Добавляем обработчик для клика по тексту вопроса (например, в теге <strong>)
      const questionText = li.querySelector('strong');
      if (questionText) {
        questionText.style.cursor = 'pointer'; // для наглядности, чтобы показать, что текст кликабельный
        questionText.addEventListener('click', function (e) {
          e.stopPropagation();
          toggleAnswer(nestedUl, toggleBtn);
        });
      }
    }
  });
});
</script>
</body>
</html>