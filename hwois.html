<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Вопросы для тестировщика</title>
    <script>
        (function () {
            const saved = localStorage.getItem('theme');
            if (saved === 'dark' || saved === 'light') {
                document.documentElement.setAttribute('data-theme', saved);
            }
        })();
    </script>
    <link rel="stylesheet" href="header.css">
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="img/QAtoDev_PageIcon.png" sizes="32x32" type="image/png">
</head>
<body>

<div class="site-header">
<nav>
    <ul>
        <li><a href="index.html" style="background-color: #FFA001;">Кто такой тестировщик?</a></li>
        <li><a href="roadmap.html">Roadmap</a></li>
        <li><a href="questions.html">Вопросы</a></li>
        <li><a href="interview.html">Интервью</a></li>
        <li><a href="practice.html">Практика</a></li>
    </ul>
</nav>
<header class="welcome">
    <div class="header-container">
        <div class="logo" onclick="window.location.href='index.html'">
            <img src="img/QAtoDev_(Flappy_Bird_style).png" alt="Логотип">
        </div>
        <h3 class="site-title">На главную</h3>
    </div>

    <!-- выносим кнопку туды-перёды -->
    
</header>
<div class="theme-switcher">
        <button
                id="theme-toggle"
                class="clean-btn toggleButton_gllP"
                type="button"
                title="Переключить тему"
                aria-label="Переключить тему"
                aria-live="polite"
        >
            <!-- Солнце для светлой темы -->
            <svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR">
                <path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path>
            </svg>
            <!-- Полумесяц для тёмной темы -->
            <svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR">
                <path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path>
            </svg>
        </button>
    </div>
</div>
<h2>Кто такой тестировщик и чем он занимается в 2026?</h2>

<section id="whois" class="article">
    <p>Тестировщик играет ключевую роль на многих этапах разработки ПО. Без тестировщика и обеспечения качества продукта невозможно пройти все этапы разработки:</p>

    <div class="sdlc-trainer" aria-live="polite">
        <div class="trainer-intro">
            <h3>Этапы разработки программного обеспечения</h3>
            <p>Это тренажер: нажимайте на этап в схеме и сразу видите объяснение и пример. Цикл замкнут — опыт релиза и поддержки возвращается в идеи.</p>
        </div>

        <div class="sdlc-layout">
            <div class="stage-scheme" role="tablist" aria-label="Схема этапов разработки ПО">
                <div class="stage-list">
                    <button class="stage-node is-active" type="button" data-stage="idea" role="tab" aria-selected="true">Идея</button>
                    <button class="stage-node" type="button" data-stage="business" role="tab" aria-selected="false">Бизнес анализ</button>
                    <button class="stage-node" type="button" data-stage="system" role="tab" aria-selected="false">Системный анализ</button>
                    <button class="stage-node" type="button" data-stage="dev" role="tab" aria-selected="false">Разработка</button>
                    <button class="stage-node" type="button" data-stage="qa" role="tab" aria-selected="false">Тестирование</button>
                    <button class="stage-node" type="button" data-stage="release" role="tab" aria-selected="false">Релиз</button>
                    <button class="stage-node" type="button" data-stage="support" role="tab" aria-selected="false">Поддержка</button>
                </div>
            </div>

            <div class="stage-details-frame">
                <div class="stage-details">
                    <article class="stage-panel is-active" data-stage="idea" role="tabpanel">
                        <img src="img/Car1.jpeg" alt="Идея">
                        <h4>Идея</h4>
                        <p>Обычно под идеей подразумевают стратегию внедрения, формирование концепции будущего продукта/фичи. В крупных компаниях задача на реализацию идет "сверху".</p>
                        <p><strong>Пример для джунов:</strong> есть общее представление или частичное требование «легковой автомобиль».</p>
                        <p><strong>Роль тестировщика:</strong> конкретной обязанности на данном этапе нет, задача еще не готова для погружения в бизнес и системные требования. Здесь больше задействован QA Lead, который оценивает трудозатраты и в дальнейшем распределяет PBI между тестировщиками.</p>
                    </article>
                    <article class="stage-panel" data-stage="business" role="tabpanel">
                        <img src="img/Car2.jpeg" alt="Бизнес анализ">
                        <h4>Бизнес анализ</h4>
                        <p>Изучение рыночных потребностей, оценка возможностей и рисков. Как лучше и выгодней с точки зрения бизнеса внедрить нововведение. Недоработка бизнес требований в последствии создает баги в удобстве использования и в клиентском пути.</p>
                        <p><strong>Пример для джунов:</strong> бизнес смотрит конкурентов и решает, что нужно «управление вентиляцией в салоне».</p>
                        <p><strong>Роль тестировщика:</strong> подключается под конец этапа, пишет поверхностный чек-лист по готовым бизнес требованиям.</p>
                    </article>
                    <article class="stage-panel" data-stage="system" role="tabpanel">
                        <img src="img/Car3.jpeg" alt="Системный анализ">
                        <h4>Системный анализ</h4>
                        <p>Детальное проектирование архитектуры системы и определение функциональных (системных) требований. Проектирование макетов в Figma относится к данному этапу. Недоработка системных требований создает баги в интеграции между сервисами: API (Шаблоны), База Данных, Back-End (Микросервисы), Front-End.</p>
                        <p><strong>Пример для джунов:</strong> системный аналитик описывает, как именно должна работать система вентиляции, какие кнопки, сценарии, ограничения.</p>
                        <p><strong>Роль тестировщика:</strong> проектирует точные проверки в формате ЧЛ/ТК и готовит тестовые данные и доступы.</p>
                    </article>
                    <article class="stage-panel" data-stage="dev" role="tabpanel">
                        <img src="img/Car4.jpeg" alt="Разработка">
                        <h4>Разработка</h4>
                        <p>Программирование, интеграция модулей и создание функционала.</p>
                        <p><strong>Пример для джунов:</strong> разработчик реализует систему вентиляции по требованиям, иногда уточняет или корректирует детали.</p>
                        <p><strong>Роль тестировщика:</strong> подключается к концу этапа с готовыми проверками и готовится к тестированию.</p>
                    </article>
                    <article class="stage-panel" data-stage="qa" role="tabpanel">
                        <img src="img/Car5.jpeg" alt="Тестирование">
                        <h4>Тестирование</h4>
                        <p>Проверка работоспособности, поиск и исправление ошибок (валидация багов), проверочное тестирование.</p>
                        <p><strong>Пример для джунов:</strong> проверяем вентиляцию по ЧЛ/ТК, сравниваем ожидаемое и фактическое.</p>
                        <p><strong>Роль тестировщика:</strong> заводит баг-репорты, коммуницирует с разработчиком, после исправлений проводит проверочное тестирование.</p>
                    </article>
                    <article class="stage-panel" data-stage="release" role="tabpanel">
                        <img src="img/Car6.jpeg" alt="Релиз">
                        <h4>Релиз</h4>
                        <p>Выпуск продукта, его сопровождение, обновления.</p>
                        <p><strong>Пример для джунов:</strong> переносим машину на следующий контур, проводим смоук и регресс, затем — в автосалон (PROD/ПРОМ).</p>
                        <p><strong>Роль тестировщика:</strong> делает смоук новых задач и регресс всей функциональности, на ПРОМ — повторный смоук.</p>
                    </article>
                    <article class="stage-panel" data-stage="support" role="tabpanel">
                        <img src="img/Car7.jpeg" alt="Поддержка">
                        <h4>Поддержка</h4>
                        <p>Поддержка доступности ПО для установки и использования, регистрация новых пользователей, добавление контента без прямого релиза.</p>
                        <p><strong>Пример для джунов:</strong> проверяем, что пользователи действительно видят новинку, баннеры обновлены, информация корректна.</p>
                        <p><strong>Роль тестировщика:</strong> конкретной обязанности нет, параллельно собираются метрики качества по стендам.</p>
                    </article>
                </div>
            </div>
        </div>
    </div>

    <p>
        Жизненный цикл ПО (SDLC) – более широкое понятие, которое охватывает все стадии существования программного продукта от идеи до вывода из эксплуатации: Планирование, Анализ, Дизайн, Разработка и тестирование, Имплементация, Поддержка. Тестировщику достаточно придерживаться знаний этапов разработки ПО.
    </p>

    <h3>Роль тестировщика в процессе разработки ПО (на всех этапах)</h3>
    <p>
        Ниже расписан полный этап тестирования отдельной PBI (задачи/фичи):
    </p>
    <ol>
        <li><strong>Тест-анализ</strong>: Анализ требований, поиск серых зон, коммуникация с аналитиком и разработчиком. Обычно старт как только готовы системные требования;</li><br>
        <li><strong>Тест-дизайн</strong>: Разработка тестовых сценариев, описание техник тест-дизайна, описание проверок, подготовка тестовых данных. Обычно старт как только начался этап разработки;</li><br>
        <li><strong>Тестирование</strong>: Проведение различных видов тестирования для выявления багов по написанным ТК/ЧЛ на этапе Тест-дизайна. Обычно старт как только задачу реализовал разработчик;</li><br>
        <li><strong>Баг-трекинг и коммуникации</strong>: Трекинг ошибок и общение с разработчиками для их устранения. Этот этап плотно пересекается с тестированием, остается дождаться исправление багов;</li><br>
        <li><strong>Смоук + регресс тестирование</strong>: Поддержание качества продукта при миграции с тестовых стендов на PROD/ПРОМ (промышленный стенд). Обычно это часть этапа "Релиз";</li><br>
        <li><strong>Корректировка тестового плана</strong>: Разбор полета (выгрузка метрик качества релиза/спринта/квартала), автоматизация этапов тестирования для повышения эффективности процесса.</li>
    </ol>
    <p>
        Благодаря детальной работе тестировщика, продукт проходит тщательную проверку, что помогает снизить количество ошибок, повысить надёжность системы и обеспечить удовлетворенность пользователей.
    </p>
    <div class="qa-spotlight">
        <img src="img/QA.jpeg" alt="Тестировщик">
        <div class="qa-text">
            <p><strong>Самое главное - это подсветить разницу между QA (обеспечение качества), QC (контроль качества) и тестировщиком!</strong></p>
            <p>QA (обеспечение качества) – это системный подход, ориентированный на разработку и внедрение процессов, стандартов и методологий, направленных на предотвращение дефектов на всех этапах жизненного цикла продукта. Он включает планирование, обучение, аудит процессов и постоянное совершенствование работы команды.</p>
            <p>QC (контроль качества) – это практический набор действий по проверке готового продукта на соответствие заданным требованиям и стандартам. Он сосредоточен на выявлении и документировании ошибок через тестирование, инспекции и валидацию, обеспечивая, что конечный продукт отвечает ожиданиям.</p>
            <p>Тестировщик – это специалист, который непосредственно осуществляет проверки, пишет тест-кейсы и автоматизированные скрипты, проводит тестирование (как ручное, так и автоматизированное) и документирует найденные дефекты. Он действует на пересечении QA и QC: участвует в разработке тестовой стратегии (часть QA) и выполняет проверки продукта (часть QC).</p>
        </div>
    </div>
</section>


<section id="glossary" class="article">
    <div class="glossary-head">
        <h3>Глоссарий</h3>
        <div class="glossary-controls">
            <button class="glossary-nav prev" type="button" aria-label="Предыдущая карточка">‹</button>
            <button class="glossary-nav next" type="button" aria-label="Следующая карточка">›</button>
        </div>
    </div>
    <div class="glossary-carousel">
        <div class="glossary-viewport">
            <div class="glossary-track">
                <div class="glossary-card">
            <h4>ИФТ стенд</h4>
            <p>Интеграционно-функциональное тестирование. Фокусируется на функциональном взаимодействии модулей после их интеграции. Здесь проверяется, что каждая часть системы выполняет свою задачу и правильно обменивается данными с другими компонентами.</p>
                </div>
                <div class="glossary-card">
            <h4>ПСИ стенд</h4>
            <p>Приёмо-сдаточные испытания. Ориентирован на комплексное тестирование всей системы. Здесь учитываются не только функциональные аспекты, но и производительность, безопасность, взаимодействие с внешними системами и другие эксплуатационные характеристики.</p>
                </div>
                <div class="glossary-card">
            <h4>PROD/ПРОМ стенд</h4>
            <p>Это окружение (среда), где программное обеспечение работает в «боевом» режиме, то есть используется конечными пользователями в реальных условиях эксплуатации.</p>
                </div>
                <div class="glossary-card">
            <h4>Смоук тестирование</h4>
            <p>Выполняется на начальном этапе тестирования после сборки программного продукта. Если основные функции не работают, дальнейшее тестирование становится бессмысленным, и сборку возвращают на доработку.</p>
                </div>
                <div class="glossary-card">
            <h4>Регресс тестирование</h4>
            <p>После внесения изменений, исправлений или добавления нового функционала проводится повторное тестирование системы, чтобы проверить, что старые функции по-прежнему работают корректно.</p>
                </div>
            </div>
        </div>
    </div>
    <p>В совокупности, смоук тестирование помогает быстро выявить критичные дефекты на ранней стадии, а регресс тестирование обеспечивает стабильность и сохранение качества при внесении изменений в продукт.</p>
</section>

<footer class="qatodev">
    <p><a href="start.html" target="_blank">Как появился тестировщик?</a></p>
</footer>

<script>
    (function() {
        const chips = document.querySelectorAll('.stage-node');
        const panels = document.querySelectorAll('.stage-panel');

        function activate(stage) {
            chips.forEach((chip) => {
                const isActive = chip.dataset.stage === stage;
                chip.classList.toggle('is-active', isActive);
                chip.setAttribute('aria-selected', isActive ? 'true' : 'false');
            });
            panels.forEach((panel) => {
                panel.classList.toggle('is-active', panel.dataset.stage === stage);
            });
        }

        chips.forEach((chip) => {
            chip.addEventListener('click', () => activate(chip.dataset.stage));
        });
    })();
</script>

<script>
    (function() {
        const carousel = document.querySelector('.glossary-carousel');
        if (!carousel) return;

        const viewport = carousel.querySelector('.glossary-viewport');
        const track = carousel.querySelector('.glossary-track');
        const prevBtn = document.querySelector('.glossary-nav.prev');
        const nextBtn = document.querySelector('.glossary-nav.next');

        let originalCards = Array.from(track.children);
        let perView = 3;
        let index = 0;
        let cardWidth = 0;
        let originalCount = 0;
        let isAnimating = false;
        let startX = 0;
        let deltaX = 0;

        function getPerView() {
            return window.matchMedia('(max-width: 720px)').matches ? 1 : 3;
        }

        function buildTrack() {
            perView = getPerView();
            originalCount = originalCards.length;
            track.style.transition = 'none';
            track.innerHTML = '';

            const headClones = originalCards.slice(-perView).map((node) => node.cloneNode(true));
            const tailClones = originalCards.slice(0, perView).map((node) => node.cloneNode(true));

            headClones.forEach((node) => track.appendChild(node));
            originalCards.forEach((node) => track.appendChild(node));
            tailClones.forEach((node) => track.appendChild(node));

            index = perView;
            requestAnimationFrame(() => {
                const gapValue = parseFloat(getComputedStyle(track).gap) || 0;
                cardWidth = track.children[index].getBoundingClientRect().width + gapValue;
                moveTo(index, false);
            });
        }

        function moveTo(nextIndex, animate = true) {
            if (animate) {
                track.style.transition = 'transform 0.35s ease';
            } else {
                track.style.transition = 'none';
            }
            const offset = -(nextIndex * cardWidth);
            track.style.transform = `translateX(${offset}px)`;
            index = nextIndex;
        }

        function handleLoop() {
            if (index < perView) {
                moveTo(index + originalCount, false);
            } else if (index >= originalCount + perView) {
                moveTo(index - originalCount, false);
            }
        }

        function next() {
            if (isAnimating) return;
            isAnimating = true;
            moveTo(index + 1, true);
        }

        function prev() {
            if (isAnimating) return;
            isAnimating = true;
            moveTo(index - 1, true);
        }

        track.addEventListener('transitionend', () => {
            isAnimating = false;
            handleLoop();
        });

        nextBtn.addEventListener('click', next);
        prevBtn.addEventListener('click', prev);

        track.addEventListener('pointerdown', (event) => {
            startX = event.clientX;
            deltaX = 0;
            track.setPointerCapture(event.pointerId);
        });

        track.addEventListener('pointermove', (event) => {
            if (!startX) return;
            deltaX = event.clientX - startX;
        });

        track.addEventListener('pointerup', () => {
            if (Math.abs(deltaX) > 40) {
                deltaX < 0 ? next() : prev();
            }
            startX = 0;
            deltaX = 0;
        });

        window.addEventListener('resize', () => {
            buildTrack();
        });

        buildTrack();
    })();
</script>

<script>
    (function() {
      const root = document.documentElement;
      const btn  = document.getElementById('theme-toggle');

      // Восстановление при загрузке
      const saved = localStorage.getItem('theme');
      if (saved === 'dark' || saved === 'light') {
        root.setAttribute('data-theme', saved);
        btn.classList.toggle('active', saved === 'dark');
      }

      // Обработчик клика
      btn.addEventListener('click', () => {
        const next = root.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
        root.setAttribute('data-theme', next);
        localStorage.setItem('theme', next);
        btn.classList.toggle('active', next === 'dark');
      });
    })();
</script>

<script>
    (function() {
      // Список ваших логотипов
      const imgs = [
        'img/QAtoDev_(Flappy_Bird_style).png',
        'img/QAtoDev_Classic.png',
        'img/QAtoDev_new_year.png',
        'img/QAtoDev_DayQA.png',
        'img/QAtoDev_Halloween.png',
        'img/QAtoDev_BlackAndWhite.png',
        'img/QAtoDev_CoverChatChannel.png'
        // …и т.д.
      ];

      // Восстанавливаем последний индекс (или 0, если нет)
      let idx = parseInt(localStorage.getItem('logoIdx'), 10);
      if (isNaN(idx) || idx < 0 || idx >= imgs.length) {
        idx = 0;
      }

      const logoImg    = document.querySelector('.logo img');
      const faviconTag = document.querySelector('link[rel="icon"]');

      // Функция установки текущего логотипа и favicon
      function updateLogo() {
        const src = imgs[idx];
        if (logoImg)    logoImg.src    = src;
        if (faviconTag) faviconTag.href = src;
      }

      // Обновляем сразу при загрузке
      updateLogo();

      // Каждые 60 секунд переключаем и сохраняем индекс
      setInterval(() => {
        idx = (idx + 1) % imgs.length;
        localStorage.setItem('logoIdx', idx);
        updateLogo();
      }, 50000);
    })();
</script>

  <script src="header.js"></script>
</body>
</html>
