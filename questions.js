document.addEventListener('DOMContentLoaded', async () => {
  const SCROLL_POS_KEY = "questions_scroll_y_v1";
  const savedScrollY = Number(sessionStorage.getItem(SCROLL_POS_KEY) || 0);
  window.addEventListener("scroll", () => {
    sessionStorage.setItem(SCROLL_POS_KEY, String(window.scrollY || 0));
  }, { passive: true });
  window.addEventListener("beforeunload", () => {
    sessionStorage.setItem(SCROLL_POS_KEY, String(window.scrollY || 0));
  });

const systemPrompt =
  "You are an AI assistant for interview preparation in the IT field, specializing in roles such as Test Engineer, QA, AQA, and Test Automation. " +
  "Answer all user queries in Russian and maintain the context of software testing throughout. " +
  "If the user submits only a single term or skill (for example, “Postman” or “SQL”), provide a clear definition, explain its purpose, and describe typical use cases. " +
  "If the user submits a full interview question, respond with a detailed, structured answer in Russian, without generating additional follow-up questions. " +
  "Provide a concise but rich summary: максимум смысла, минимум воды, основные пункты + практические примеры при необходимости. " +
  "Суммарный объем ответа должен укладываться в лимит 1000 токенов. " +
  "Не используй таблицы, графики, диаграммы и лишнее оформление в ответе. " +
  "Do not use markdown, asterisks, or other formatting characters—deliver plain text responses.";

const refineSystemPrompt =
  "Ты ИИ-помощник для подготовки к собеседованию QA/тестировщика. " +
  "Отвечай на русском языке, кратко и по делу, с фокусом на выделенном фрагменте и уточняющем вопросе пользователя. " +
  "Используй переданный контекст вопроса и предыдущего ответа, не игнорируй его. " +
  "Дай более детальное пояснение, практичный пример и возможные ошибки/риски в рамках темы. " +
  "Без таблиц, графиков, диаграмм и лишнего оформления. " +
  "Ответ в пределах 1000 токенов.";

      // 2) Ваш полный массив вопросов-ответов:
     const data = [
        {
          category: 'ТЕОРИЯ ТЕСТИРОВАНИЯ + СОФТЫ',
          items: [
            {
              id: 'accordion_theory_q1',
              title: 'Расскажите про ваше достижение или проект, которым вы гордитесь?',
              answer: 'Расскажите структурировано про ваши пет-проекты, процесс обеспечения качества ПО, взаимодействие со смежными командами и всё то, что подчёркивает в вас инициативность и командный дух.'
            },
            {
              id: 'accordion_theory_q2',
              title: 'Представьте, что вы не справляетесь с задачей и горит дедлайн. Ваши действия?',
              answer: 'Актуализировать сроки завершения задачи и подсветить риски на дейли и общем собрании. Далее указать причины и все риски (например, отсутствие аналитики, нехватка тестовых данных, сложность взаимодействия со смежными командами). Обратиться за помощью к аналитику или QA-лиду, главное – не ждать у моря погоды.'
            },
            {
              id: 'accordion_theory_q3',
              title: 'Работал ли ты единственным тестировщиком в команде?',
              answer: 'Вопрос задаётся для проверки самостоятельности в команде. Если вы не были единственным тестировщиком, расскажите, какую роль вы выполняли. Обычно тестировщик прогоняет ручные тесты, но не всегда пишет их самостоятельно.'
            },
            {
              id: 'accordion_theory_q4',
              title: 'Тестировали удобства использования?',
              answer: 'Проводили анализ конкурентов (схожего ПО) и оценивали принципы UI/UX. Важно также упомянуть коммуникацию с аналитиком и дизайнером.'
            },
            {
              id: 'accordion_theory_q5',
              title: 'Занимался исследовательским тестированием?',
              answer: 'Проверка опыта проектирования тестовой документации и использования техник тест-дизайна. <br><br>Пример: в рамках тест-дизайна исследовательское тестирование использовал до погружения в требования и выявления серых зон.'
            },
            {
              id: 'accordion_theory_q6',
              title: 'Что такое ad-hoc?',
              answer: 'Ad-hoc тестирование (также – интуитивное или свободное тестирование) – это метод тестирования ПО, проводимый без какого-либо конкретного плана или заранее определенного набора шагов.<br><br>Вместо этого тестировщики используют свою интуицию, опыт и творческий подход для выявления дефектов и проблем, которые не могут обнаружить более формальные методы тестирования.'
            },
            {
              id: 'accordion_theory_q7',
              title: 'Какие бывают виды требований?',
              answer: 'Требования делятся на прямые и косвенные.<br><br>Прямые - бизнес требования, системные требования, спецификации, макеты приложения, отчеты от заказчика.<br><br>Косвенные - анализ конкурентов, UX принципы, удобство использования приложения, отчеты бета-тестов.'
            },
            {
              id: 'accordion_theory_q8',
              title: 'Бывало такое, что ты не разрешал выпускать фичу в релиз?',
              answer: 'Вопрос на проверку коммуникации как внутри, так и между командами. <br><br>Безусловно были моменты, когда функциональность еще не готова, а сроки релиза не давали возможности закончить тестирование. Я всегда подсвечивал риск обнаружения багов на этапе релиза. <br><br>Agile позволяет исправить ошибку в кратчайшие сроки и здесь самое главное подсветить риск и сообщить как можно раньше.'
            },
            {
              id: 'accordion_theory_q9',
              title: 'Как разрешал конфликт с фронтом или бэком?',
              answer: 'Вопрос на проверку умения договорится с дорогими коллегами. <br><br>На моем опыте приходилось работать в команде, где фронт и бэк разработчики не могли договориться и самое главное в общении подключить третью сторону, чтобы не переходить на личности.'
            },
            {
              id: 'accordion_theory_q10',
              title: 'Работал без требований? Сталкивался с таким опытом?',
              answer: 'Столкнулся с неполными спецификациями: составлял интеллект-карту и матрицу трассировки для проверки покрытия. В проекте встречалось отсутствие актуальных требований – благодаря опыту знаю, как быстро их восстановить.<br><br>Пример источников: документация в Confluence, макеты в Figma, задачи в Jira, User Story, ТК и ЧЛ, запись звонка с владельцем продукта, презентация, корректировки заказчика.'
            },
            {
              id: 'accordion_theory_q11',
              title: 'Что делать, если документации нет, а протестировать функционал нужно уже завтра?',
              answer: '1. Подсветить риск владельцу продукта, что в срок не успеваешь провести тестирование.<br>2. Обозначить, к какому числу завершишь проверку.<br>Если действительно горит релиз, тестирую по неактуальным требованиям и уточняю детали у аналитика и разработчика. Этот ответ подчёркивает стрессоустойчивость и неконфликтность.'
            },
            {
              id: 'accordion_theory_q12',
              title: 'Что такое тестирование? Цель тестирования?',
              answer: 'Тестирование – процесс сопоставления спецификаций продукта с его финальным результатом. Это не просто поиск багов, а проверка соответствия ожидаемого и фактического результата.'
            },
            {
              id: 'accordion_theory_q13',
              title: 'Зачем тестировать ПО? Цель тестирования?',
              answer: 'Для предоставления актуальной информации о состоянии приложения (техническая цель) и повышения доверия пользователей (коммерческая цель).'
            },
            {
              id: 'accordion_theory_q14',
              title: 'Почему вначале позитивное, а потом негативное тестирование?',
              answer: 'Сначала убеждаемся в работоспособности функций (позитивное), а затем пытаемся найти ошибки через негативное тестирование.'
            },
            {
              id: 'accordion_theory_q15',
              title: 'Назовите пользу негативных тестов',
              answer: 'Негативное тестирование помогает выявить скрытые дефекты. <br><br>Пример: Телеграм внедрил премиум подписки, но команда при тестировании новых возможностей не учла отмену подписки после оплаты. <br><br>В итоге после отмены подписка оставалась у пользователя, но деньги все же возвращались на карту. Таким образом компания потеряла большую сумму.<br><br>Один из примеров для чего необходимо проводить негативное тестирование, хоть пример можно отнести ближе к функциональному тестированию.'
            },
            {
              id: 'accordion_theory_q16',
              title: 'Чем отличаются типы, уровни, методы? Расскажи про каждый атрибут.',
              answer: 'Типы тестирования (например, функциональное, регрессионное) определяют, что проверяется; <br><br>уровни тестирования (модульное, интеграционное, системное, приемочное) описывают этапы проверки; <br><br>методы тестирования (черного, белого, серого ящика) указывают на подходы к проверке. <br><br>Каждый атрибут помогает структурировать процесс тестирования для полного охвата функциональности приложения.'
            },
            {
              id: 'accordion_theory_q17',
              title: 'Какие уровни тестирования знаете?',
              answer: 'Модульный (компонентный), <br><br>интеграционный, <br><br>системный, <br><br>приёмочный.'
            },
            {
              id: 'accordion_theory_q18',
              title: 'Назови церемонии Agile, в которых ты участвовал?',
              answer: 'Планирование спринта, <br><br>Daily, <br><br>PBR (Груминг), <br><br>Ретро, <br><br>Демо (внутреннее и приемка с заказчиком).'
            },
            {
              id: 'accordion_theory_q19',
              title: 'Какие виды тестирования знаешь?',
              answer: 'Есть много разных классификаций видов тестирования. Первые, с которыми знакомится тестировщик, обычно делятся на три группы:<br><br>Функциональные виды тестирования — проверяют, что программа делает то, что нужно.<br><br>Нефункциональные виды тестирования — проверяют, что программа работает так, как нужно (например: безопасность, удобство использования, производительность и т.д.).<br><br>Виды тестирования, связанные с изменениями, — проверяют, что программа работает корректно после правок (например: регресс-тестирование, смоук-тесты, подтверждающее тестирование (ретест)).',

              authorCheck: 'https://t.me/testinginreality',
              avatar: 'img/avatar/testinginreality.jpeg'
            },
            {
              id: 'accordion_theory_q20',
              title: 'Виды интеграционного тестирования?',
              answer: 'Подход «Большого взрыва», нисходящий (top-down), восходящий (bottom-up), «сэндвич».'
            },
            {
              id: 'accordion_theory_q21',
              title: 'Какие техники тест-дизайна знаете?',
              answer: 'Граничные значения, <br><br>классы эквивалентности, <br><br>таблицы принятия решений, <br><br>причинно-следственная связь, <br><br>попарное тестирование, <br><br>тестирование состояний, <br><br>тестирование сценариев, <br><br>исследовательское тестирование.'
            },
            {
              id: 'accordion_theory_q22',
              title: 'Для чего нужна техника попарного тестирования?',
              answer: 'Для сокращения числа тестовых проверок при большом количестве вариантов использования.'
            },
            {
              id: 'accordion_theory_q23',
              title: 'Отличие валидации и верификации?',
              answer: 'Верификация подтверждает соответствие требованиям, валидация – достижение поставленной цели.'
            },
            {
              id: 'accordion_theory_q24',
              title: 'Этапы тестирования?',
              answer: '1. Инициация процесса тестирования.<br>2. Выявление требований.<br>3. Генерация тест-кейсов.<br>4. Отбор значимых кейсов.<br>5. Проведение тестов.<br>6. Фиксация результатов.<br>7. Анализ результатов.<br>8. Отчёт о соответствии требованиям.'
            },
            {
              id: 'accordion_theory_q25',
              title: 'Тестировали методом черного ящика? Какие методы знаете?',
              answer: 'Метод черного ящика - тестирование ПО без знания его внутренней структуры и реализации. Точнее без необходимости знания внутренней структуры и реализации. QA может знать что под капотом у ПО, но заниматься тестированием от лица пользователя.<br><br>Метод серого ящика - тестирование с некоторым представлением о внутренней структуре ПО.<br><br>Метод белого ящика - тестирование внутренней структуры и реализации ПО.'
            },
            {
              id: 'accordion_theory_q26',
              title: 'Назовите основные этапы разработки ПО',
              answer: 'ИДЕЯ - идея зарождается на любом из этапов разработки, но включается в работу вначале каждого спринта. Пример - тестировщик предложил идею как удобнее расположить форму регистрации на этапе тестирования или заказчик внес корректировки в продукт после выката на пром.<br><br>АНАЛИТИКА - системный аналитик начал работу над первичной версией документации к новой фиче. Пример - описание флоу приложения в конфлюенсе. Документация может вносить правки и корректировки даже на этапе разработки, тк приступив к написанию кода могут выясниться технические несостыковки. Это зависи от опыта аналитика и процесса работы в команде. Тестировщик приступает к тест-дизайну на этапе проектирования спецификаций. Не исключение, что QA подключается ещё на этапе идеи.<br><br>РАЗРАБОТКА - фронтенд и бэкенд, в идеале, приступают синхронно (в рамках одного спринта) над реаизацией нового функционала или корректировки старого. Вносятся небольшие изменения в спецификацию продукта. Тестировщик корректирует свои ТК в зависимости от изменений.<br><br>ТЕСТИРОВАНИЕ - в момент передачи разработкой задач на Ready For Test уже подготовлены ТК и ЧЛ для тестирования, остается сама проверка и оформление статуса, результата тестирования.<br><br>ПОДДЕРЖКА (от релиза до прома) - сама поддержка подразумевает сохранение рабочего состояния новой фичи на проме, но в таком случае у нас появляется этап РЕЛИЗ, в данном примере релиз внутри этапа поддержки и с начала переезда на релизный стенд до выката на пром - регрессионное тестирование.'
            },
            {
              id: 'accordion_theory_q27',
              title: 'Что такое DOR и DOD?',
              answer: 'DOR (Definition of Ready) – критерии готовности к разработке;<br>DOD (Definition of Done) – критерии завершённости задачи.'
            },
            {
              id: 'accordion_theory_q28',
              title: 'Знакомо понятие T-shape?',
              answer: 'T-shaped специалист – эксперт в одной области с базовыми знаниями в других.'
            },
            {
              id: 'accordion_theory_q29',
              title: 'Какая разница между чек-листом и тест-кейсом?',
              answer: 'Чек-лист — список проверок, а тест-кейс — подробное пошаговое описание пункта из этого списка. На один пункт чек-листа может приходиться несколько тест-кейсов. <br><br>По ТК протестировать ПО может человек с улицы, не имеющий представление об этом ПО, а по ЧЛ протестировать может только специалист, который знаком с ПО.'
            },
            {
              id: 'accordion_theory_q30',
              title: 'Назовите атрибуты хорошего тест-кейса',
              answer: 'ID, <br>название, <br>предусловия, <br>шаги, <br>окружение, <br>результаты (логи, скриншоты, файлы), а также доп. атрибуты - история изменений, автор и найденные баги по данному ТК'
            },
            {
              id: 'accordion_theory_q31',
              title: 'Что такое баг?',
              answer: 'Баг - это отличие ожидаемого результата ПО от фактического.<br><br>Бывают явные баги, которые содержат статус 4ХХ или UI ошибки, которые не описаны в ожидаемом поведении системы.'
            },
            {
              id: 'accordion_theory_q32',
              title: 'Какие атрибуты у баг-репорта? Основные поля для заполнения?',
              answer: 'ID, <br>название, <br>описание, <br>приоритет, <br>предусловия, <br>шаги, <br>постусловия, <br>ожидаемый и фактический результат, <br>окружение, <br>приложения (логи, скриншоты).'
            },
            {
              id: 'accordion_theory_q33',
              title: 'Какая разница между приоритетом и серьёзностью?',
              answer: 'Приоритет - это порядок, в котором разработчик должен устранить дефект, тогда как серьезность - это степень влияния дефекта на работу продукта.'
            },
            {
              id: 'accordion_theory_q34',
              title: 'Приведите примеры серьёзного, но не приоритетного бага и наоборот',
              answer: '<strong>Приоритетный, но не серьёзный</strong> - интернет-магазин прислал красное платье вместо бордового. При разработке макетов цвет кнопок поменяли местам ошибочно. Сервис работает, заказы оформляются, но код цвета не тот. Клиент в ярости.<br><br>Ошибка в соглашении пользователя (ошибка орфографическая или логическая). <br><br> <strong>Серьёзный (блокер), но не приоритетный</strong> - поломана часть функционала, которая блокирует клиентский сценарий, но т.к. старт продаж еще не скоро, то баг не серьёзный. Например: приложение аренды самокатов блочит возможость взять транспорт, но сейчас зимний сезон (прокат стартует в конце весны).'
            },
            {
              id: 'accordion_theory_q35',
              title: 'Что такое регресс и проверочное тестирование, в чём разница?',
              answer: 'Регрессионное – полная проверка системы после изменений;<br>Проверочное – проверка исправления конкретного бага.'
            },
            {
              id: 'accordion_theory_q36',
              title: 'Что такое Traceability Matrix?',
              answer: 'Матрица трассировки – таблица, связывающая требования с тестами или другими элементами, позволяющая оценить покрытие тестами.'
            },
            {
              id: 'accordion_theory_q37',
              title: 'Что такое «парадокс пестицида»?',
              answer: 'Принцип, согласно которому повторяющиеся тесты со временем начинают все реже находить ошибки на конкретных тестовых данных.',
              moreLink: 'https://habr.com/ru/articles/699990',
              authorCheck: 'https://t.me/shooandendlessagony',
              avatar: 'img/avatar/shoo.jpeg'
            },
            {
              id: 'accordion_theory_q38',
              title: 'Приведите пример хорошего тест-кейса',
              answer: 'Название, предусловия, шаги, окружение, подтверждение ожидаемого результата.<br><br>Название - Проверить отображение кнопки "Заказать" во вкладке Корзина<br><br>Предусловие - В корзине добавлен товар (Кейс 156) В Jira есть возможность добавить общий шаг (ТК внутри нового ТК)<br><br>Шаг 1 - Войти под пользователем: Admin пароль: 123<br><br>Шаг 2 - Нажать на профиль в правом верхнем углу<br><br>Шаг 3 - В отобразившемся боковом меню нажать "Корзина"<br><br>Шаг 4 - Проверить активное состояние кнопки "Заказать" (при условии если есть товар для заказа).'
            },
            {
              id: 'accordion_theory_q39',
              title: 'Что такое нагрузочное тестирование и чем отличается от стресс-тестирования?',
              answer: 'Нагрузочное тестирование оценивает поведение системы под ожидаемой рабочей нагрузкой, измеряя производительность и стабильность. <br><br>Стресс-тестирование проверяет систему за пределами нормальных условий, выявляя пределы отказоустойчивости и восстановление после перегрузок.'
            },
            {
              id: 'accordion_theory_q40',
              title: 'Какие существуют стандарты UI?',
              answer: 'Принципы KISS, Don\'t Make Me Think, знакомые элементы, соотношение сигнала и шума, принцип трёх кликов, бумажник Миллера (5–7 элементов), единый стиль, визуальная ясность.'
            },
            {
              id: 'accordion_theory_q41',
              title: 'К чему больше тянет к мобильным приложениям или веб-сервисам?',
              answer: 'Этот вопрос могут задать уже на первом HR-скриннинге при уточнении вашего опыта. Он помогает понять, к какому типу продуктов — мобильным приложениям или веб-сервисам — вы больше склоняетесь, чтобы сразу предложить проекты, где вы будете наиболее эффективны и заинтересованы. Кроме того, ответ покажет, какие инструменты и методологии тестирования вам знакомы и в каком направлении стоит развивать навыки.'
            },
            {
              id: 'accordion_theory_q42',
              title: 'Можешь ли назвать три плюса и три минуса в нашей профессии (QA)?',
              answer: '(Пример)<br><br>Плюсы: <br><br>Разнообразие задач – проверяем разные фичи, от UI до Back-end, что не дает заскучать. <br><br>Влияние на качество продукта – находя и описывая баги, вы помогаете сделать софт более надёжным и удобным для пользователей. <br><br>Непрерывное обучение – приходится разбираться в новых технологиях, инструментах и методологиях, что постоянно прокачивает ваши навыки. <br><br>Минусы: <br><br>Рутинность – при регрессионном тестировании одни и те же сценарии могут повторяться много раз. <br><br>Ограниченная видимость результатов – ваш вклад иногда не так заметен конечному пользователю, как, например, у разработчика новых фич. <br><br>Давление сроков – часто приходится жертвовать глубиной тестирования ради быстрой поставки релиза.',
              moreLink: 'https://ivaniksanov.github.io/hwois.html'
            },
            {
              id: 'accordion_theory_q43',
              title: 'Что такое санитарное тестирование?',
              answer: 'Проверяет работоспособность отдельных важных компонентов приложения. Например, можно проверить, отправляются ли нотификации, проводится ли оплата товара в приложении маркетплейса.',
              moreLink: 'https://testengineer.ru/sanity-testirovaniye/?ysclid=mau0362vc962155065'
            },
            {
              id: 'accordion_theory_q44',
              title: 'Что тебя мотивирует в рабочем процессе? Какие задачи мотивируют?',
              answer: '(Пример)<br><br>Меня заряжает ощущение пользы и роста. В работе меня мотивируют:<br><br>- Сложные и нетривиальные задачи — нужно разобраться в новой предметной области или технологии, построить стратегию тестирования с нуля.<br><br>- Видимый результат — когда найденный дефект исправлен, а пользователи получают стабильный продукт.<br><br>- Автоматизация рутины — написать автотесты, настроить CI — и освободить часы на исследовательскую работу.<br><br>- Непрерывное обучение — новые инструменты (Docker, k8s, observability-stack), подходы (TDD/BDD), сертификации.<br><br>- Сильная команда — code-review, обмен знаниями, ретроспективы, менторство.<br><br>- Чёткие цели и признание — OKR/KPI, когда бизнес и разработка благодарят за качественную обратную связь.<br><br>Особенно «зажигают» задачи, где приходится балансировать скорость релиза и качество: настройка метрик и алертов.'
            },
            {
              id: 'accordion_theory_q45',
              title: 'На какой уровень себя оцениваешь?',
              answer: '(Пример)<br><br>Оцениваю себя на уверенный Middle:<br><br>- 3+ года коммерческого опыта в веб- и мобильном тестировании.<br>- Свободно применяю техники тест-дизайна, составляю тестовую документацию, оцениваю риски.<br>- Самостоятельно строю стратегию тестирования фичи, координирую регресс и smoke.<br>- Пишу и поддерживаю автотесты (Java/Kotlin + Selenide, REST Assured, Pytest), покрытие критического пути ≈ 80 %.<br>- Настраиваю GitLab CI, Allure-отчёты, тестовую среду в Docker.<br>- Менторю стажёров, провожу внутренние воркшопы.<br><br>До уровня Senior не хватает опыта масштабирования QA-процессов на несколько кросс-функциональных команд и глубокого погружения в облачную инфраструктуру.'
            },
            {
              id: 'accordion_theory_q46',
              title: 'Какой бы вид тестирования применил до релиза и после релиза?',
              answer: 'До релиза:<br><br>1. Тестирование задачи на ТЕСТ/ИФТ стенде: модульное, интеграционное, функциональное, UI.<br>2. Нефункциональные проверки: производительность, безопасность, доступность, usability.<br>3. Smoke-тест при выкладке на тестовый (PSI/UAT) стенд — убеждаемся, что сборка запускается и критический путь «жив».<br>4. Полный регресс на UAT: автотесты + ручные edge-кейсы, проверка влияния на соседние модули.<br><br>После релиза:<br><br>1. Smoke-чеклист на PROD сразу после деплоя (health-check эндпоинты, ключевые пользовательские сценарии).<br>2. Мониторинг логов, метрик и алертов — production monitoring testing.<br>3. Пост-релизная верификация фичи на «живых» данных, сбор обратной связи от саппорта.'
            },
            {
              id: 'accordion_theory_q47',
              title: 'Какой вид тестовой документации чаще всего встречается у тестировщика?',
              answer: 'Наиболее частые артефакты:<br><br>Чек-лист — компактный список проверок без пошаговых инструкций. Удобен для быстрого покрытия новой функциональности, на этапе погружения в требования и проектирования проверок.<br><br>Тест-кейс — формальный документ с предусловиями, шагами и ожидаемым результатом. Нужен для критичных сценариев, передачи знаний, аудита и автоматизации. Тест-кейс удобен для прохождения новичком, который незнаком с ПО, а также в регрессе перед релизом новой функциональности. <br><br>Чек-лист рождается ещё на этапе проектирования, эволюционирует по мере тестирования, а самые важные пункты превращаются в полноценные тест-кейсы, которые затем попадают в регрессионный набор.',
              moreLink: ''
            },
            {
              id: 'accordion_theory_q48',
              title: 'В каких случаях больше подходит тест кейс, в каких чек-лист?',
              answer: 'Чек-листы пишут на этапе проектирования тест дизайна, описание проверок на основе требований и на этапе тестирования функциональности - очень удобно и быстро набросать список проверок на основе требований. Тест-кейсы пишут после релиза, например версия 1.5, и эти кейсы будут включены в регресс следующего релиза 1.6 (регрессионное тестирование).<br><br>Чек-лист подходит для тестировщика, который знаком с ПО и с его функционалом, специалист может приступить к проверке, ориентируясь по одному предложению "проверить отправку заявок в поддержку", а Тест-кейс это подробно описанный сценарий действий, в котором есть название, подготовка тестовых данных, шаги, ожидаемый результат.',
              moreLink: 'https://practicum.yandex.ru/blog/chto-takoe-test-keys-i-kak-ego-sostavit/'
            },
            {
              id: 'accordion_theory_q49',
              title: 'Можешь ли описать характеристики хороших требований?',
              answer: 'Самое главное - Есть критерии приемки (AC) и Клиентский путь, по которому можно убедится в работоспособности данной функциональности. Плюсом будет: <br><br> Описание бизнес логики (проблематика) и системные требования (техническое описание работы) <br><br> История изменений данных требований (когда вносились правики и что изменилось) <br><br> Автор требований, разработчик данной фичи.',
              moreLink: 'https://habr.com/ru/articles/542128/',
              img: 'img/CryingCat.jpeg'
            },
            {
              id: 'accordion_theory_q50',
              title: 'Ты тест-план когда-нибудь составлял? Знаешь, из чего он состоит?',
              answer: '(Пример)<br><br>Да, составлял. Шаблон моего тест-плана включает:<br><br>1. Цель и область — какие модули/версии входят, что исключено.<br>2. Документы-источники — BRD, ТЗ, дизайн-спецификация, user-stories.<br>3. Подход и виды тестирования — функциональное, API, UI, нагрузка, безопасность, регресс, smoke.<br>4. Роли и ответственность — QA, Dev, PO, точки эскалации.<br>5. Среда и инструменты — стенды, данные, браузеры/OS, CI, фреймворки.<br>6. Критерии входа/выхода — Definition of Ready/Done, баг-трэшхолд.<br>7. Риск-матрица — вероятность × влияние, план смягчения.<br>8. График и ресурсы — оценки (man-days), релизный календарь.<br>9. Метрики и отчётность — % покрытия, баги по severity, time-to-fix.<br>10. Регресс и smoke — когда и что запускаем.<br>11. Коммуникации — формат и периодичность статус-репортов.<br>12. Артефакты — местоположение чек-листов, тест-кейсов, отчётов.<br><br>Документ живёт в Confluence и актуализируется перед каждым крупным релизом.'
            },
            {
              id: 'accordion_theory_q51',
              title: 'Какие основные инструменты используешь для тестирования?',
              answer: 'Web-тестирование:<br><br> (АПИ) Postman | Insomnia<br> (Дизайн) Figma | Picso<br>(Клиент) Браузеры (Chrome, Yandex, Safari)<br>(АПИ и ЛОГИ) DevTools<br>(БАГ-трекинг) Jira<br>(БД) DBeaver<br>(РЕДАКТОР) IntelliJ IDEA | VisualStudio | PyCharm<br> (КЛИЕНТ и ЛОГИ) Terminal<br> (ЛОГИ) Kibana<br>(ГИТ) BitBucket | SourceTree<br>(Чек-лист) Obsidian | Excel<br><br>Mobile-тестирование:<br><br>Postman | Insomnia<br>Figma | Picso<br>iOS | Android<br>App Store | Google Play<br>Firebase | TestFlight<br>Android Studio | Xcode<br>Jira<br>DBeaver<br>Charles<br>Kibana<br>Git (BitBucket | SourceTree)<br>Чек-лист (Obsidian | Excel)',
              img: 'img/answer/Skills.jpg'
            },
            {
              id: 'accordion_theory_q52',
              title: 'Как ты понимаешь, что такое валидация на бэке и верификация на фронте?',
              answer: 'Верификация и валидация — это два разных аспекта проверки качества ПО, которые происходят на разных этапах разработки.<br><br>Верификация программного обеспечения (verification) — это проверка соответствия заявленным требованиям, проектной документации, техническим спецификациям и стандартам. Она необходима, чтобы убедиться, что создание продукта проходит правильно.<br><br>Валидация (validation), в переводе на русский, — это проверка, в процессе которой выясняется, соответствует ли ПО реальным ожиданиям пользователей и выполняет ли оно свою основную функцию в реальной среде. Фактически валидация продукта проводится, чтобы оценить работоспособность продукта и его соответствие запросу рынка.<br><br>Таким образом валидация на бэке это проверка соответсвия системных требований с реализованным функционалом (Взаимодействие API, сохранение признаков в БД, взаимодействие микросервисов и т.д.), а валидация на фронте это проверка работоспообности функционала по клиентскому пути.',
              moreLink: 'https://ru.hexlet.io/blog/posts/chto-takoe-verifikatsiya-i-validatsiya-v-testirovanii-po-i-programmirovanii',
              img: 'img/answer/VeriforValid.jpeg'
            },
            {
              id: 'accordion_theory_q53',
              title: 'Что такое динамическое тестирование?',
              answer: 'Динамическое тестирование — это способ тестирования ПО, который происходит через выполнение кода. Динамическое тестирование оценивает поведение ИТ-продукта в реальных условиях, в отличие от статического тестирования. <br><br>Статическое тестирование — поиск дефектов без запуска кода/программы. Делается на артефактах: требования, макеты, спецификации, код. Методы: ревью, инспекции, статический анализ кода и моделей. <br><br> Статическое: <br>Ревью требований (поиск серых зон). <br>Code review по чек-листу. <br>Статический анализ: стиль, сложность, потенциальные NPE/утечки (SonarQube, ESLint, Pylint, Checkstyle, SpotBugs и т.п.).<br><br>Динамическое:<br> Функциональные тесты: юнит (JUnit/pytest), интеграционные, системные, приемочные.<br> Нефункциональные: нагрузка/производительность (JMeter, Gatling), безопасность (OWASP ZAP/Burp), надежность, совместимость, юзабилити.<br> Запуск автотестов (смоук/регресс): Selenium, Cypress, Playwright.'
            },
            {
              id: 'accordion_theory_q54',
              title: 'Вопросы на софты без конкретного ответа',
              answer: 'Какая ваша самая сильная/слабая сторона?<br>Как вы справляетесь с критикой?<br>Что бы вы хотели улучшить в себе?<br>Что вы делаете, если не хватает ресурсов?<br>Как вы приоритизируете задачи?<br>Как вы реагируете на просьбу поработать на выходных?<br>Как справляетесь с многозадачностью?<br>Как работаете с трудными коллегами?<br>Что для вас важно в руководителе?<br>Как делитесь знаниями?<br>Какие роли предпочитаете?<br>Как даёте обратную связь?<br>Как убеждаете команду?<br>Как справляетесь с рутиной?<br>Какие проекты вдохновляют?<br>Работа индивидуально или в команде?<br>Какие навыки хотите развить?<br>Как реагируете на неудачи?<br>Что цените в работе?<br>Почему ушли с прошлого места?<br>Как учились навыкам?<br>Планы на развитие?<br>Фронтенд или бэкенд?<br>Какие книги/каналы читаете?<br>Как развиваете софт-скиллы?'
            }
          ]
        },
        {
          category: 'WEB',
          items: [
            {
              id: 'accordion_web_q1',
              title: 'Что такое браузер?',
              answer: 'Браузер – программа для просмотра веб-страниц, которая преобразует полученный код в визуальные элементы. <br><br>Технический ответ: Браузер выступает в качестве клиента в клиент-серверной архитектуре.'
            },
            {
              id: 'accordion_web_q2',
              title: 'Какие движки браузеров ты знаешь? Зачем это знать QA?',
              answer: 'Blink (Chrome, Edge, Opera, Yandex Браузер, Brave) <br><br>WebKit (Safari) <br><br>Gecko (Firefox) <br><br>Trident (Internet Explorer) <br><br>EdgeHTML (старые версии Edge до 2020 года).<br><br>Знание движков и различие между браузерами позволяет ориентироваться в кросс-браузерном тестировании. (Отображение веб-сервиса на разных браузерах может отличаться из-за оссобенностей рендеринга страницы).<br><br>Некоторые баги возникают только в одном браузере и не воспроизводятся в других — даже на том же движке.<br><br>Chromium — это не движок, а открытый проект браузера от Google, который служит основой для (Chrome, Edge, Opera, Yandex Браузер, Brave). Он использует движок Blink для рендеринга веб-страниц.',
              moreLink: 'https://habr.com/ru/articles/853680/'
            },
            {
              id: 'accordion_web_q3',
              title: 'Что происходит, когда мы вводим в строку браузера github.com?',
              answer: 'Если мы уже посещали данный сайт, то в кэше браузера хранится IP-адрес сайта. Это можно заметить, когда вводишь первые буквы и появляется подсказка.<br><br>Если сайт не был посещен ранее, браузер связывается с DNS-сервером, который ищет IP-адрес сайта. После получения IP-адреса по нему запрашивается код страницы.<br><br>В данном случае github.com - это как имя контакта "Суши" в вашем телефоне, а IP-адрес - это номер телефона. Когда вы вводите "Суши", телефон показывает номер, чтобы совершить звонок. Так же, когда вы вводите github.com, DNS определяет IP-адрес, чтобы браузер мог загрузить страницу.',
              moreLink: 'https://habr.com/ru/companies/gnivc/articles/861432/'
            },
            {
              id: 'accordion_web_q4',
              title: 'Что такое HTML/CSS/JavaScript?',
              answer: 'HTML, CSS и JavaScript — это как три стихии: Вода, Огонь и Воздух. Каждый из них отвечает за свою функцию.<br><br>HTML отвечает за разметку элементов на сайте. (DOM страницы).<br><br>CSS отвечает за стилизацию элементов (внешний вид).<br><br>JavaScript отвечает за действия и интерактивность на странице (анимации, обработка событий).',
              moreLink: 'https://doka.guide/tools/how-the-browser-creates-pages/'
            },
            {
              id: 'accordion_web_q5',
              title: 'Какие вкладки Chrome DevTools взаимодействуют с HTML/CSS/JS?',
              answer: 'В основном используются следующие вкладки в панели разработчика (DevTools):<br><br>1. Elements:<br>- Здесь можно просмотреть и изменить HTML-разметку страницы.<br>- Можно также изменять и просматривать примененные CSS-стили.<br><br>2. Sources:<br>- В этой вкладке можно просматривать и отлаживать JavaScript-код.<br>- Можно ставить точки останова, отслеживать выполнение кода и анализировать скрипты.<br><br>3. Console:<br>- Позволяет выполнять JavaScript-код в реальном времени и выводить различные данные для диагностики.<br>- Полезна для просмотра ошибок и логов во время выполнения скриптов.<br><br>4. Network:<br>- Отслеживает запросы и загрузку различных ресурсов, таких как HTML, CSS и JavaScript файлы.<br>- Полезна для анализа производительности и решения проблем с сетевыми запросами.',
              moreLink: 'https://htmlacademy.ru/blog/soft/chrome-devtools-2'
            },
            {
              id: 'accordion_web_q6',
              title: 'Что такое клиент-серверная архитектура?',
              answer: 'Клиент-серверная архитектура — это архитектурный стиль, при котором идет взаимодействие клиента (например, браузера) и сервера посредством передачи данных.<br><br>Клиент отправляет запрос на сервер, который может взаимодействовать с базой данных для сохранения, изменения или чтения информации.<br><br>Основные роли:<br><br>• Клиент: отправляет запросы и отображает информацию пользователю.<br><br>• Балансировщик нагрузки (Load Balancer): распределяет входящие запросы между несколькими серверами для оптимизации нагрузки.<br><br>• Сервер: обрабатывает запросы клиентов и взаимодействует с базой данных.<br><br>• База данных (БД): хранит данные и отвечает на запросы сервера.',
              moreLink: 'https://doka.guide/tools/web-app-works/',
              img: 'img/answer/client-server-2.jpg'
            },
            {
              id: 'accordion_web_q7',
              title: 'Какие бывают виды клиент-серверной архитектуры?',
              answer: 'Одноуровневая (1-tier):<br>Клиент и сервер расположены на одном устройстве. Примеры: Приложение для работы в оффлайн-режиме с локальными данными.<br><br>Двухуровневая (2-tier):<br>Клиент и сервер разделены, клиент взаимодействует с сервером напрямую. Примеры: Приложения, требующие прямого доступа к базе данных через сеть.<br><br>Трехуровневая (3-tier):<br>Включает три уровня: клиент, приложение (аппликейшн) сервер, и сервер базы данных. Веб-приложения, где клиент обращается к веб-серверу, который в свою очередь взаимодействует с базой данных.<br><br>Многоуровневая (n-tier):<br>Состоит из нескольких уровней, обеспечивающих дополнительную гибкость и масштабируемость. Уровни могут включать веб-серверы, серверы приложений, базы данных и другие сервисные уровни. Сложные корпоративные приложения, требующие высокой масштабируемости и производительности.<br><br>Peer-to-Peer (P2P):<br>Каждый узел может выступать в роли клиента и сервера одновременно. Системы для обмена файлами, криптовалюты.Микросервисная архитектура:<br>Приложение разрабатывается как набор небольших, независимых сервисов, каждый из которых выполняет одну четко определенную функцию и взаимодействует с другими службами через API. Современные веб-приложения, требующие высокой гибкости и возможностей для частого обновления.',
              moreLink: 'https://itelon.ru/blog/arkhitektura-klient-server/'
            },
            {
              id: 'accordion_web_q8',
              title: 'Что может выступать в качестве клиента?',
              answer: 'Веб-браузеры, нативные и гибридные приложения, командная строка.'
            },
            {
              id: 'accordion_web_q9',
              title: 'Что такое протокол передачи данных? Назови основные',
              answer: 'Сетевой протокол — это набор правил, определяющих принципы взаимодействия устройств в сети (клиента и сервера).<br><br>Основной протокол HTTP — это незащищенный протокол. Его часто можно встретить на сайтах с тестами на характер. Например, если результат теста можно отправить другому человеку, просто переслав ему ссылку, это указывает на использование HTTP. Рядом с доменом сайта обычно нет значка "замочка".<br><br>HTTPS — это защищенная версия HTTP, обеспечивающая шифрование данных для безопасного взаимодействия в сети. Самый популрный защищенный протокол.<br><br>Основные: HTTPS, FTP, SMTP, DNS, NTP.'
            },
            {
              id: 'accordion_web_q10',
              title: 'Что такое микросервисы? Расскажите про микросервисную архитектуру?',
              answer: 'Микросервисная архитектура — это способ построения приложений, которые состоят из независимых друг от друга небольших модулей.<br><br>Подход к тестированию микросервисной архитектуры отличается от всем привычного. Она представляет собой совокупность мелких сервисов, каждый из которых отвечает за определенный функционал, а вместе они представляют собой готовое приложение и решают определенную глобальную задачу.<br><br>Главным преимуществом и одновременно трудностью тестирования является то, что они располагаются на различных серверах и написаны на разных языках программирования, таких как Java и .Net.Фактически разработчики определённого микросервиса не знают, что делают остальные микросервисы, что усложняет процесс тестирования. Но зато мы можем быстро обновить и протестировать отдельный микросервис, не затронув другие.',
              moreLink: 'https://doka.guide/tools/microservices/'
            },
            {
              id: 'accordion_web_q11',
              title: 'Работал с DevTools? Чем он полезен?',
              answer: 'Использовал DevTools для отладки кода, анализа DOM, мониторинга сетевых запросов и профилирования производительности.',
              moreLink: 'https://htmlacademy.ru/blog/soft/how-to-devtools'
            },
            {
              id: 'accordion_web_q12',
              title: 'Где смотреть ответы от сервера?',
              answer: 'Ответы от сервера можно наблюдать на вкладке <strong>Network</strong> в DevTools, где отображаются запросы, статусы и данные ответов.'
            },
            {
              id: 'accordion_web_q13',
              title: 'Как скопировать текст со страницы в DevTools?',
              answer: 'В панели Elements можно выбрать элемент инструментом "Цель", правой кнопкой мыши выбрать "Copy → Copy element" или "Edit as HTML", чтобы скопировать текст.'
            },
            {
              id: 'accordion_web_q14',
              title: 'Назови основные вкладки DevTools и их назначение',
              answer: 'Основные вкладки: Elements (DOM и стили), Console (вывод ошибок и логирование), Network (мониторинг HTTP-запросов), Sources (отладка кода), Performance (анализ производительности), Application (работа с кэшем и куки).'
            },
            {
              id: 'accordion_web_q15',
              title: 'Где эмулировать состояние сети?',
              answer: 'Вкладка <strong>Network</strong> → Throttling.'
            },
            {
              id: 'accordion_web_q16',
              title: 'Что такое куки и кэш?',
              answer: 'Куки – данные для идентификации сессии; кэш – временное хранение ресурсов для ускорения загрузки.',
              moreLink: 'https://allsoft.ru/news-soft/chto-takoe-kesh-kuki-i-zachem-ikh-chistit/'
            },
            {
              id: 'accordion_web_q17',
              title: 'Как очистить кэш браузера?',
              answer: 'Кэш можно очистить через настройки браузера или через DevTools (вкладка Application), а также с помощью сочетания клавиш (например, Ctrl+Shift+Delete).'
            },
            {
              id: 'accordion_web_q18',
              title: 'Что такое cURL? Для чего используют?',
              answer: 'cURL – командная утилита для передачи данных с использованием URL-синтаксиса, применяемая для отправки HTTP-запросов и отладки API.'
            },
            {
              id: 'accordion_web_q19',
              title: 'Что такое User Agent? Какие данные содержит?',
              answer: 'User Agent – строка, описывающая браузер, его версию, операционную систему и устройство, отправляемая в HTTP-заголовках для идентификации клиента.'
            },
            {
              id: 'accordion_web_q20',
              title: 'Что такое сниффер? Для чего предназначен?',
              answer: 'Инструмент перехвата и анализа сетевого трафика для диагностики, отладки и проверки безопасности. Программы: Charles, Fiddler, Wireshark. <br><br>С помощью сниффера мы можем подменить статусный код от сервера, например вместо 200 получить 403 и проверить как клиент обработает данный статус - выведет заглушку.',
              moreLink: 'https://habr.com/ru/companies/maxilect/articles/554888/'
            },
            {
              id: 'accordion_web_q21',
              title: 'Какие виды локаторов есть? Преимущества/недостатки?',
              answer: 'Локаторы: ID (быстрый и уникальный), name, class, CSS (легковесные и гибкие), XPath (гибкий, позволяет навигацию по DOM, но медленнее) и link text (для ссылок, зависящий от текста).'
            },
            {
              id: 'accordion_web_q22',
              title: 'Отличие CSS от XPath?',
              answer: 'CSS локаторы проще и быстрее, но не поддерживают сложную иерархическую навигацию, в отличие от XPath, который позволяет детальный поиск в DOM, хотя может работать медленнее.',
              moreLink: 'https://testengineer.ru/xpath-vs-css-selector-locator/'
            },
            {
              id: 'accordion_web_q23',
              title: 'Какие виды веб-приложений знаешь/тестировал?',
              answer: 'Существуют разные виды веб-приложений в зависимости от архитектуры и задач. Одностраничные приложения (SPA) работают без перезагрузки страницы и часто используют React или Vue. Приложения с серверным рендерингом (SSR) генерируют HTML на сервере, что улучшает SEO и скорость загрузки. Статически сгенерированные сайты (SSG) создаются заранее и быстро загружаются с CDN, хорошо подходят для блогов и документации. Прогрессивные веб-приложения (PWA) работают как мобильные приложения — могут работать офлайн, слать уведомления и устанавливаться на устройство.',
              moreLink: 'https://doka.guide/tools/web-app-types/'
            },
            {
              id: 'accordion_web_q24',
              title: 'Локализуй баг на веб-странице',
              answer: 'Ты тестируешь логин форму:<br><br>1) вводишь валидный логин,<br>2) вводишь валидный пароль,<br>3) нажимаешь кнопку войти,<br>4) обновляется страница,<br>5) и ты остаешься разлогинен.<br>Твои действия?<br><br>Нам необходимо локализовать ошибку:<br><br>1) Для начала нужно открыть DevTools (Network) и повторить действия в режиме инкогнито, чтобы проверить какой запрос отправляется, его ответ и  статус-код. Если запроса не было с авторизацией, то отследить при нажатии на кнопку какой запрос отправляется или почему кнопка "Войти" вызывает обновление страницы.<br><br>2) Открыть вкладку Console и проверить информацию об ошибках в файлах javascript.<br><br>Можно предположить, что ошибка в переадресации при логине со статус-кодом 3ХХ или кнопка "Войти" вызывает обновление страницы.<br><br>3) Найти токен авторизации, убедится в корректности логина и пароля (даже если ты уверен что они верные + убедится в корректности тестового стенда: логин и пароль от ИФТ, а ты пытаешься войти на ПСИ). <br><br>4) Проверить в логах (Кибана) историю авторизации, проверить уровни логов (INFO, DEBUG, ERROR).<br><br>5) Зайти в БД и проверить сохранение последней сессии авторизации.<br><br>6) Если вышеперечисленное не помогло локализовать причину данного поведения - обратится за помощью к разработчику (фронту/бэку). Если есть новость про найденный инцидент другими тестировщиками, то для начала сконнектиться с ними.',
              img: 'img/answer/formLogin.png'
            }
          ]
        },
        {
          category: 'API',
          items: [
            {
              id: 'accordion_api_q1',
              title: 'Что такое API?',
              answer: 'API (Application Programming Interface) – набор протоколов и инструментов для создания программ, который определяет, как программные компоненты взаимодействуют друг с другом.',
              moreLink: 'https://doka.guide/tools/api/'
            },
            {
              id: 'accordion_api_q2',
              title: 'Из чего состоит URL?',
              answer: 'URL состоит из схемы (например, http/https), домена, порта (опционально), пути, параметров запроса и фрагмента (якоря).',
              moreLink: 'https://www.dev-notes.ru/articles/devops/whats-in-a-url/'
            },
            {
              id: 'accordion_api_q3',
              title: 'Что такое REST/RestFull?',
              answer: 'REST – архитектурный стиль для разработки веб-сервисов, использующий стандартные методы HTTP. RESTful сервисы придерживаются этих принципов для обеспечения масштабируемости и простоты интеграции.'
            },
            {
              id: 'accordion_api_q4',
              title: 'Отличия REST от SOAP?',
              answer: 'REST – легковесный, использующий HTTP и часто JSON; SOAP – протокол с формальной спецификацией, использующий XML и требующий дополнительных контрактов (WSDL).'
            },
            {
              id: 'accordion_api_q5',
              title: 'Какой формат передачи информации в SOAP, а какой в REST?',
              answer: 'SOAP использует XML для обмена сообщениями, а REST чаще всего использует JSON, хотя может работать и с XML.'
            },
            {
              id: 'accordion_api_q6',
              title: 'Назови основные методы REST',
              answer: 'GET — получить представление ресурса без изменения его состояния<br><br>POST — создать новый ресурс<br><br>PUT — заменить существующий ресурс полностью<br><br>DELETE — удалить ресурс<br><br>PATCH — частично обновить ресурс<br><br>OPTIONS — узнать, какие методы и возможности поддерживает ресурс<br><br>HEAD — как GET, но без тела ответа (только заголовки)'
            },
            {
              id: 'accordion_api_q7',
              title: 'Какая разница между GET и POST?',
              answer: 'GET используется для получения данных и не изменяет состояние сервера (отсутсвует тело запроса), а POST отправляет данные, часто изменяя состояние сервера, при этом данные передаются в теле запроса.',
              moreLink: 'https://htmlacademy.ru/blog/php/get-vs-post'
            },
            {
              id: 'accordion_api_q8',
              title: 'Какие отличия между XML и JSON?',
              answer: 'XML – разметочный язык с тегами и атрибутами, более формальный и гибкий; JSON – компактный, легкий для чтения и парсинга, предпочтительный для веб-сервисов.'
            },
            {
              id: 'accordion_api_q9',
              title: 'Назови статусы ответов',
              answer: 'Статусы делятся на классы: 1xx (информационные), 2xx (успешные, например, 200 OK), 3xx (перенаправления), 4xx (ошибки клиента, например, 404 Not Found) и 5xx (ошибки сервера, например, 500 Internal Server Error).'
            },
            {
              id: 'accordion_api_q10',
              title: 'Где смотреть статусы ответов?',
              answer: 'Статусы ответов можно увидеть во вкладке Network в DevTools, а также в логах сервера или в инструментах для тестирования API, таких как Postman/Insomnia/Charles'
            },
            {
              id: 'accordion_api_q11',
              title: 'Опишите каждый класс ответов (1xx, 2xx и т.д.)',
              answer: '1xx – информационные, 2xx – успешные, 3xx – перенаправления, 4xx – ошибки клиента, 5xx – ошибки сервера.'
            },
            {
              id: 'accordion_api_q12',
              title: 'Что такое HTTP?',
              answer: 'HTTP (Hypertext Transfer Protocol) – протокол передачи данных между клиентом и сервером, используемый в сети Интернет.'
            },
            {
              id: 'accordion_api_q13',
              title: 'Основные методы HTTP:',
              answer: 'GET — получить представление ресурса без изменения его состояния<br><br>POST — создать новый ресурс<br><br>PUT — заменить существующий ресурс полностью<br><br>DELETE — удалить ресурс<br><br>PATCH — частично обновить ресурс<br><br>OPTIONS — узнать, какие методы и возможности поддерживает ресурс<br><br>HEAD — как GET, но без тела ответа (только заголовки)'
            },
            {
              id: 'accordion_api_q14',
              title: 'Что такое Postman/Insomnia?',
              answer: 'Postman и Insomnia – инструменты для тестирования API, позволяющие отправлять HTTP-запросы, просматривать ответы и автоматизировать тестовые сценарии.',
              img: 'img/answer/postman.jpeg'
            },
            {
              id: 'accordion_api_q15',
              title: 'Что такое коллекция?',
              answer: 'Коллекция – набор сохранённых запросов и тестов, сгруппированных по проекту или функциональности для удобства повторного использования.'
            },
            {
              id: 'accordion_api_q16',
              title: 'Как расшифровывается CRUD?',
              answer: 'CRUD – Create, Read, Update, Delete – базовые операции для работы с данными.'
            },
            {
              id: 'accordion_api_q17',
              title: 'Что такое глобальная переменная?',
              answer: 'Глобальная переменная — это переменная, которая доступна во всех запросах и скриптах вне зависимости от активного окружения (переменных окружения). Она используется для хранения универсальных данных, которые часто переиспользуются, например: имя пользователя, дата рождения и др.<br><br>Пример глобальных переменных:<br>- {{fullName}} = Иванов Иван Иванович<br>- {{birthDate}} = 01.01.1999<br><br>Если в окружении PROD заданы переменные (переменные окружения prod) с теми же именами:<br>- {{fullName}} = Петров Петр Петрович<br>- {{birthDate}} = 15.05.1985<br>— то они переопределят глобальные значения. Это удобно, когда для ПРОД-среды нужны реальные данные, а для тестовых — универсальные.'
            },
            {
              id: 'accordion_api_q18',
              title: 'Что такое переменная окружения?',
              answer: 'Переменная окружения — это переменная, значение которой применяется только в рамках выбранного окружения. Она позволяет удобно переключаться между тестовыми стендами без необходимости менять URL и другие параметры вручную.<br><br>Пример использования в запросе:<br>GET {{URL}}/api/v1/profile<br><br>Значения переменной {{URL}} в разных окружениях:<br>- dev: https://api.dev.qatodev.ru<br>- tst: https://api.tst.qatodev.ru<br>- prep: https://api.prep.qatodev.ru<br>- prod: https://api.qatodev.ru<br><br>Таким образом, один и тот же запрос может выполняться на разных стендах, просто за счёт выбора нужного окружения. Переменная окружения полезна не для одного запроса, а для целой коллекции запросов, где поменять url достаточно сложно вручную. Например, в 130 запросах невозможно вручную сменить тестовый стенд с tst на prep.'
            },
            {
              id: 'accordion_api_q19',
              title: 'Что нельзя положить в коллекцию?',
              answer: 'Конфиденциальные данные (пароли, ключи) и нестабильные значения, нарушающие повторяемость тестов.'
            },
            {
              id: 'accordion_api_q20',
              title: 'На каком языке пишутся API автотесты?',
              answer: 'Java, Python, JavaScript, C# – зависит от фреймворка и инфраструктуры проекта.'
            },
            {
              id: 'accordion_api_q21',
              title: 'Как объяснишь пятилетнему ребенку что такое Rest API?',
              answer: 'Представь, что у тебя есть умные голуби, которые носят письма от одного замка к другому. Каждый замок — это как отдельный домик-програмка (микросервис), и у каждого есть свой адрес. Когда ты отправляешь голубя с письмом (запрос через REST API), он летит в другой замок и возвращается с ответом.<br><br>Если голубь вернулся с письмом — всё хорошо, это как статус 200.<br>Если вернулся, но письмо пустое или с надписью “что-то пошло не так” — это тоже 200, но с ошибкой внутри.<br>Если ты написал письмо неправильно (например, без имени получателя) — голубь не летит, это ошибка 400 (ошибка клиента).<br>А если в том замке всё сломалось, и никто не смог ответить — это ошибка 500 (ошибка сервера).'
            },
            {
              id: 'accordion_api_q22',
              title: 'Какие знаете средства тестирования API?',
              answer: 'Postman. Insomnia. SoapUI. Tricentis Tosca. Apigee. Jmeter.'
            },
            {
              id: 'accordion_api_q23',
              title: 'Что такое идемпотентность запросов?',
              answer: 'Идемпотентность HTTP-метода — это свойство, при котором повтор одного и того же запроса даёт то же серверное состояние, что и единичный вызов. <br><br>Идемпотентные методы: <br>GET - Чтение ресурса. Повторять можно; не должен менять состояние (логи не в счёт).<br>HEAD - Как GET, но только заголовки.<br>PUT - Полная запись ресурса по известному URI. Повторный такой же PUT оставит ресурс тем же. Подходит для upsert по фиксированному идентификатору. <br>DELETE - Удаление ресурса. Повторный DELETE может дать 404, но состояние сервера одинаковое. <br>OPTIONS - Узнать, что поддерживает сервер/ресурс. <br>TRACE - Диагностика запроса (редко используется).',
              moreLink: 'https://www.securitylab.ru/analytics/563109.php'
            }
          ]
        },
        {
          category: 'БАЗЫ ДАННЫХ',
          items: [
            {
              id: 'accordion_db_q1',
              title: 'Что такое БД?',
              answer: 'База данных (БД) – систематизированное хранилище данных, управляемое СУБД, которое обеспечивает хранение, поиск и модификацию информации.',
              moreLink: 'https://sql-academy.org/ru/guide/basic-database-concepts'
            },
            {
              id: 'accordion_db_q2',
              title: 'Типы БД',
              answer: 'Основные типы:<br><br>реляционные (MySQL, PostgreSQL, Oracle Database, Microsoft SQL Server, SQLite)<br>документо-ориентированные (MongoDB, CouchDB, Amazon DocumentDB)<br>ключ-значение (Redis, Amazon DynamoDB)<br>графовые базы данных (ArangoDB, OrientDB)<br>колонно-ориентированные БД (Apache Cassandra, ClickHouse, Amazon Redshift)<br>объектно-ориентированные БД (ObjectDB)',
              moreLink: 'https://sql-academy.org/ru/guide/relation-databases'
            },
            {
              id: 'accordion_db_q3',
              title: 'Отличие реляционных от нереляционных БД?',
              answer: 'Реляционные БД используют таблицы с фиксированной схемой и SQL для запросов, тогда как нереляционные БД гибче, масштабируются горизонтально и используют различные модели данных.',
              moreLink: 'https://sql-academy.org/ru/guide/structure-of-relation-databases'
            },
            {
              id: 'accordion_db_q4',
              title: 'Назови структуру запроса в БД (SELECT FROM WHERE ORDER BY GROUP BY)',
              answer: 'SELECT - Определяет, какие столбцы или выражения извлекаются<br>DISTINCT - Убирает повторяющиеся строки из результатов<br>FROM - Указывает таблицу(ы) или подзапрос, откуда берутся данные<br>JOIN - Объединяет данные из нескольких таблиц<br>WHERE - Фильтрует строки до группировки<br>GROUP BY - Группирует строки по значениям одного или нескольких столбцов<br>HAVING - Фильтрует группы после группировки<br>UNION / INTERSECT/ EXCEPT - Оперирует над результатами нескольких запросов<br>ORDER BY - Сортирует результат по одному или нескольким столбцам<br>LIMIT - Ограничивает количество возвращаемых строк<br>OFFSET - Пропускает указанное количество строк в выводе<br><br>Пример:<br><br><code>SELECT DISTINCT department, COUNT(*) AS total<br>FROM employees<br>JOIN departments ON employees.dept_id = departments.id<br>WHERE salary > 50000<br>GROUP BY department<br>HAVING COUNT(*) > 3<br>ORDER BY total DESC<br>LIMIT 10 OFFSET 5;</code><br>'
            },
            {
              id: 'accordion_db_q5',
              title: 'Типы JOIN? (показать на кругах Эйлера)',
              answer: 'Основные типы JOIN: INNER JOIN, LEFT (OUTER) JOIN, RIGHT (OUTER) JOIN, FULL (OUTER) JOIN и CROSS JOIN – используются для объединения строк из разных таблиц по общему полю.',
              moreLink: 'https://sql-academy.org/ru/guide/multi-table-request-join'
            },
            {
              id: 'accordion_db_q6',
              title: 'Для чего используем ORDER BY/GROUP BY?',
              answer: 'ORDER BY используется для сортировки результатов, а GROUP BY – для агрегирования данных по определённому критерию с последующим применением агрегатных функций.',
              moreLink: 'https://sql-academy.org/ru/guide/sorting'
            },
            {
              id: 'accordion_db_q7',
              title: 'Какая разница между DROP, TRUNCATE и DELETE?',
              answer: 'DROP удаляет таблицу вместе со структурой.<br>Пример: <code>DROP TABLE employees;</code><br><br>TRUNCATE удаляет все записи, сохраняя структуру таблицы.<br>Пример: <code>TRUNCATE TABLE employees;</code><br><br>DELETE удаляет строки из таблицы (можно использовать WHERE).<br>Пример: <code>DELETE FROM employees WHERE department = "Sales";</code>'
            },
            {
              id: 'accordion_db_q8',
              title: 'Назови порядок выполнения SELECT-запроса',
              answer: '1.	FROM — выбор таблицы или таблиц (и JOIN’ы, если есть)<br>2.	WHERE — фильтрация строк<br>3.	GROUP BY — группировка строк<br>4.	HAVING — фильтрация групп (после группировки)<br>5.	SELECT — выбор нужных столбцов и выражений<br>6.	DISTINCT — удаление дубликатов (если есть)<br>7.	ORDER BY — сортировка результата<br>8.	LIMIT / OFFSET — ограничение количества строк<br><br>Пример:<br><br><code>SELECT department, COUNT(*) AS total_employees<br>FROM employees<br>WHERE salary > 50000<br>GROUP BY department<br>HAVING COUNT(*) > 5<br>ORDER BY total_employees DESC<br>LIMIT 10;</code><br>'
            },
            {
              id: 'accordion_db_q9',
              title: 'Выведи из таблицы Product пять продуктов, у которых price выше 1000',
              answer: '<code>SELECT *<br>FROM Product<br>WHERE price > 1000<br>ORDER BY price DESC<br>LIMIT 5;</code><br>'
            },
            {
              id: 'accordion_db_q10',
              title: 'Как объединить 2 таблицы?',
              answer: '1. INNER JOIN — внутреннее соединение:<br>Выбирает только совпадающие строки из обеих таблиц по условию.<br><br><code>SELECT *<br>FROM table1<br>INNER JOIN table2<br>ON table1.id = table2.id;</code><br><br>2. LEFT JOIN (или LEFT OUTER JOIN):<br>Берёт все строки из левой таблицы, и только совпадающие — из правой. Если в правой нет соответствия — подставляется NULL.<br><br><code>SELECT *<br>FROM table1<br>LEFT JOIN table2<br>ON table1.id = table2.id;</code><br><br>3. RIGHT JOIN (или RIGHT OUTER JOIN):<br>То же самое, но наоборот: все строки из правой таблицы, и только совпадающие — из левой.<br><br><code>SELECT *<br>FROM table1<br>RIGHT JOIN table2<br>ON table1.id = table2.id;</code><br><br>4. FULL JOIN (или FULL OUTER JOIN):<br>Возвращает все строки из обеих таблиц. Там, где нет совпадений, подставляется NULL.<br><br><code>SELECT *<br>FROM table1<br>FULL JOIN table2<br>ON table1.id = table2.id;</code><br>'
            },
            {
              id: 'accordion_db_q11',
              title: 'Что такое оконная функция?',
              answer: 'Оконная функция в SQL выполняет вычисления по набору строк, связанных с текущей строкой, без группировки, позволяя получать, например, ранжирование или суммарные значения по разделам.',
              moreLink: 'https://sql-academy.org/ru/guide/windows-functions'
            },
            {
              id: 'accordion_db_q12',
              title: 'Что такое подзапросы?',
              answer: 'Подзапрос – это запрос, вложенный в другой запрос, используемый для вычисления значений или фильтрации данных.',
              moreLink: 'https://sql-academy.org/ru/guide/nested-sql-queries'
            },
            {
              id: 'accordion_db_q13',
              title: 'Для чего используют агрегатные функции?',
              answer: 'Агрегатные функции (SUM, COUNT, AVG, MIN, MAX) используются для вычисления сводных значений по набору строк.',
              moreLink: 'https://htmlacademy.ru/blog/php/mysql-functions'
            },
            {
              id: 'accordion_db_q14',
              title: 'Приведи пример запроса на вычисление среднего значения стоимости в столбце Price',
              answer: 'Пример: <code>SELECT AVG(Price) AS AvgPrice FROM Products;</code>',
              moreLink: 'https://sql-academy.org/ru/guide/aggregate-functions'
            },
            {
              id: 'accordion_db_q15',
              title: 'Какими способами подключиться к БД?',
              answer: 'Подключение возможно через клиентские приложения (например, pgAdmin, SQL Developer), драйверы для языков программирования (JDBC, ODBC), командную строку или ORM фреймворки.'
            },
            {
              id: 'accordion_db_q16',
              title: 'Самая популярная агрегатная функция (COUNT)?',
              answer: 'COUNT подсчитывает количество строк или ненулевых значений в наборе данных.<br><br>Примеры:<br><br>– <code>SELECT COUNT(*) FROM table</code> — общее число строк<br><br>– <code>SELECT COUNT(column) FROM table</code> — число ненулевых значений в column<br><br>– <code>SELECT COUNT(DISTINCT column) FROM table</code> — число уникальных значений column'
            },
            {
              id: 'accordion_db_q17',
              title: 'Что такое ER-диаграмма? Как с ней работать?',
              answer: 'ER-диаграмма (Entity–Relationship Diagram) — это наглядная схема, на которой прямоугольники представляют таблицы базы данных, а линии между ними показывают связи через первичные (PK) и внешние ключи (FK).<br><br>Шпаргалка при отсутствии описания:<br><br>Если официальной документации по базе нет, диаграмма подскажет, какие поля где лежат: любая таблица на схеме имеет пометки PK (первичный ключ) и FK (внешний ключ), по которым легко отследить, как таблицы «склеиваются» между собой.<br><br>Поиск клиентских данных:<br><br>Когда нужно понять, где хранятся данные о клиенте — например, ФИО в одной таблице, паспортные данные в другой — по линиям связей вы находите, что поле client_id из таблицы clients (где ФИО) «смотрит» на такое же поле в таблице passports. Значит, именно по этому ключу можно собрать все сведения о пользователе в одном запросе.<br><br>Где смотреть ER-диаграмму:<br><br>При подключении к БД через MySQL Workbench, DBeaver, DataGrip, pgAdmin и т.п.',
              moreLink: 'https://getanalyst.ru/database/how-to-visualize-er-model',
              img: 'img/answer/er-diagram.jpeg'
            }
          ]
        },
        {
          category: 'GIT + IDE + SELENIUM',
          items: [
            {
              id: 'accordion_git_q1',
              title: 'Что такое GIT?',
              answer: 'Git – распределённая система контроля версий, позволяющая отслеживать изменения в коде, работать с ветками и объединять изменения от разных разработчиков.'
            },
            {
              id: 'accordion_git_q2',
              title: 'Основные команды GIT',
              answer: '<code>git init</code> — создаёт новый пустой Git-репозиторий в текущей директории<br><br><code>git clone</code> — клонирует удалённый репозиторий на локальную машину<br><br><code>git add</code> — добавляет изменения (файлы/папки) в индекс для следующего коммита<br><br><code>git commit</code> — фиксирует проиндексированные изменения, создавая новый коммит с сообщением<br><br><code>git push</code> — отправляет ваши локальные коммиты в удалённый репозиторий<br><br><code>git pull</code> — загружает изменения из удалённого репозитория и сливает их с текущей веткой<br><br><code>git branch</code> — отображает список веток или создаёт новую ветку<br><br><code>git merge</code> — сливает указанную ветку в текущую и объединяет их историю<br><br><code>git checkout</code> — переключается на указанную ветку или откатывает файлы к состоянию из коммита<br><br><code>git status</code> — показывает состояние рабочего каталога и индекса (изменённые, неотслеживаемые файлы и т. д.)<br><br><code>git log</code> — выводит историю коммитов текущей ветки, включая автора и сообщения коммитов',
              moreLink: 'https://htmlacademy.ru/blog/git/git-console'
            },
            {
              id: 'accordion_git_q3',
              title: 'С какими клиентами GIT работал?',
              answer: 'Работал с Git CLI, GitHub Desktop, SourceTree, GitKraken, а также с интегрированными системами в IDE, такими как IntelliJ IDEA и Visual Studio Code.'
            },
            {
              id: 'accordion_git_q4',
              title: 'Что такое репозиторий?',
              answer: 'Репозиторий – хранилище проекта, содержащее файлы, историю изменений и метаданные, доступное локально и/или удалённо.'
            },
            {
              id: 'accordion_git_q5',
              title: 'Что такое commits, branches?',
              answer: 'Commit – зафиксированное изменение с сообщением; branch – отдельная линия разработки, позволяющая работать над фичами независимо от основной ветки.'
            },
            {
              id: 'accordion_git_q6',
              title: 'Что такое Pull request?',
              answer: 'Pull request – запрос на слияние ветки с основной, сопровождаемый обсуждением изменений и код-ревью.'
            },
            {
              id: 'accordion_git_q7',
              title: 'Как клонировать репозиторий?',
              answer: '<code>git clone &lt;URL&gt;</code> создаёт локальную копию репозитория.'
            },
            {
              id: 'accordion_git_q8',
              title: 'Что такое ООП? Назовите принципы с примерами',
              answer: 'ООП (Объектно-Ориентированное Программирование) основывается на принципах инкапсуляции, наследования, полиморфизма и абстракции, позволяющих структурировать код с помощью классов и объектов.',
              moreLink: 'https://gitverse.ru/blog/articles/development/172-obuektno-orientirovannoe-programmirovanie-oop-chto-eto-takoe-osnovnye-principy-i-struktura'
            },
            {
              id: 'accordion_git_q9',
              title: 'Что такое SOLID? Приведите примеры',
              answer: 'SOLID – набор принципов разработки: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion. Эти принципы помогают создавать расширяемый и поддерживаемый код.'
            },
            {
              id: 'accordion_git_q10',
              title: 'Что такое DRY, KISS, YAGNI?',
              answer: 'DRY (Dont Repeat Yourself) – избегать дублирования кода; KISS (Keep It Simple, Stupid) – сохранять простоту; YAGNI (You Arent Gonna Need It) – не реализовывать функциональность заранее.'
            },
            {
              id: 'accordion_git_q11',
              title: 'Что такое Selenium?',
              answer: 'Selenium – фреймворк для автоматизации тестирования веб-приложений, позволяющий управлять браузерами через WebDriver.'
            },
            {
              id: 'accordion_git_q12',
              title: 'Что такое WebDriver?',
              answer: 'WebDriver – интерфейс API в Selenium, обеспечивающий взаимодействие с браузером для имитации действий пользователя.'
            },
            {
              id: 'accordion_git_q13',
              title: 'Зачем нужны TestNG/JUnit?',
              answer: 'TestNG и JUnit – тестовые фреймворки для Java, позволяющие структурировать, выполнять и отчитываться о тестах с использованием аннотаций и ассертов.'
            },
            {
              id: 'accordion_git_q14',
              title: 'Что такое assertions?',
              answer: 'Assertions – проверки, сравнивающие ожидаемый результат с фактическим, сигнализирующие об ошибке при несоответствии.'
            },
            {
              id: 'accordion_git_q15',
              title: 'Что такое Selenium Waits? Какие есть и чем отличаются?',
              answer: 'Selenium Waits – механизмы ожидания для синхронизации тестов. Неявные ожидания устанавливают глобальный таймаут, а явные позволяют ожидать конкретное условие для элемента.'
            },
            {
              id: 'accordion_git_q16',
              title: 'Что такое CI/CD?',
              answer: 'CI/CD (Continuous Integration/Continuous Deployment) – практика автоматизации сборки, тестирования и развертывания кода для быстрого и стабильного релиза.'
            },
            {
              id: 'accordion_git_q17',
              title: 'Что такое Jenkins?',
              answer: 'Jenkins – сервер автоматизации, используемый для настройки CI/CD pipeline, сборки, тестирования и деплоя проектов.'
            },
            {
              id: 'accordion_git_q18',
              title: 'Как настроить Job или Pipeline?',
              answer: 'Настройка включает создание конфигурационного файла (например, Jenkinsfile) с шагами сборки, тестирования и деплоя, а также настройку триггеров для автоматического запуска при изменениях в репозитории.'
            },
            {
              id: 'accordion_git_q19',
              title: 'С какими IDE работали?',
              answer: 'Работал с IntelliJ IDEA, Eclipse, Visual Studio Code, PyCharm – выбор зависит от стека технологий.',
              moreLink: 'https://htmlacademy.ru/blog/soft/editors-for-the-coders-in-2025'
            },
            {
              id: 'accordion_git_q20',
              title: 'Что такое Maven?',
              answer: 'Maven – инструмент для управления проектами на Java, обеспечивающий сборку, управление зависимостями и стандартизированную структуру проекта через POM-файл.',
              moreLink: 'https://javarush.com/groups/posts/3119-java-proekt-ot-a-do-ja-vse-chto-vih-khoteli-znatjh-o-maven'
            },
            {
              id: 'accordion_git_q21',
              title: 'Что такое POM файл в Maven?',
              answer: 'POM файл (Project Object Model) в Maven представляет собой XML-файл, который содержит информацию о проекте и его конфигурации, включая зависимости, сборку проекта, плагины и другие параметры.',
              moreLink: 'https://ru.hexlet.io/blog/posts/apache-maven-chto-eto-i-kak-ispolzovat-v-java'
            },
            {
              id: 'accordion_git_q22',
              title: 'Что такое PageObject и PageFactory?',
              answer: 'PageObject – паттерн для организации автотестов, где каждая страница представлена классом с методами взаимодействия. PageFactory – инструмент для инициализации элементов страницы, упрощающий работу с локаторами.',
              moreLink: 'https://testengineer.ru/bolshoj-gajd-po-page-object-model/'
            },
            {
              id: 'accordion_git_q23',
              title: 'Какая разница между String, StringBuffer и StringBuilder?',
              answer: 'String – неизменяемая строка; StringBuffer – изменяемая строка с синхронизацией (потокобезопасная); StringBuilder – изменяемая строка без синхронизации (быстрее в однопоточной среде).',
              moreLink: 'https://habr.com/ru/articles/260767/'
            }
          ]
        },
        {
          category: 'DEVOPS',
          items: [
            {
              id: 'accordion_devops_q1',
              title: 'Что такое Docker?',
              answer: 'Контейнер Docker — это изолированное окружение, в котором выполняется приложение вместе со всеми его зависимостями, библиотеками и конфигурациями, используя ресурсы операционной системы. Контейнеры обеспечивают консистентность и портативность приложений, позволяя им работать одинаково в различных средах.',
              moreLink: 'https://doka.guide/tools/docker/'
            },
            {
              id: 'accordion_devops_q2',
              title: 'Отличие виртуальных машин от контейнеров?',
              answer: 'Виртуальные машины запускают полноценные ОС поверх гипервизора; контейнеры используют ядро хоста и изолируют процессы, что легче и быстрее.',
              moreLink: 'https://habr.com/ru/articles/474068/'
            },
            {
              id: 'accordion_devops_q3',
              title: 'Что такое Dockerfile?',
              answer: 'Dockerfile — это текстовый файл, содержащий инструкции для сборки Docker-образа. Он определяет, какие базовые образы использовать, какие файлы и зависимости добавить, и какие команды выполнить, чтобы создать контейнер с необходимой средой выполнения.'
            },
            {
              id: 'accordion_devops_q4',
              title: 'Опишите составные части архитектуры Docker',
              answer: 'Основные составные части архитектуры Docker — это:<br><br>сервер, содержит сервис Docker, образы и контейнеры. Сервис связывается с Registry, образы — метаданные приложений, запускаемых в контейнерах Docker.<br><br>клиент, применяется для запуска различных действий на сервере Docker.<br><br>registry, используется для хранения образов. Есть публичные, доступные каждому, например, Docker Hub и Docker Cloud.'
            },
            {
              id: 'accordion_devops_q5',
              title: 'Расскажите, как проходил релиз в вашей команде?',
              answer: 'Релиз осуществлялся через CI/CD pipeline с автоматической сборкой, тестированием, развёртыванием и валидацией на средах staging и production.'
            },
            {
              id: 'accordion_devops_q6',
              title: 'Что такое CI/CD?',
              answer: 'CI/CD (Continuous Integration/Continuous Delivery) — это практика автоматизации процессов интеграции кода, тестирования и доставки в production.<br><br>CI подразумевает частые коммиты в общий репозиторий с автоматической сборкой и тестированием (например, через GitHub Actions или Jenkins).<br><br>CD — это автоматизированный деплой после успешного CI, будь то staging или production (например, через Kubernetes или AWS CodeDeploy).'
            }
          ]
        },
        {
        category: 'Вопросы к руководителю | команде | HR',
        items: [
            {
            id: 'accordion_hr_q1',
            title: 'Работать на своей технике или выдают ноут, мониторы и др.',
            answer: 'Позволяет выяснить, обеспечит ли компания всё необходимое оборудование для продуктивной работы или потребуется использовать собственные устройства.'
            },
            {
            id: 'accordion_hr_q2',
            title: 'Есть возможность обучения, корпоративные курсы, профессиональные сообщества?',
            answer: 'Помогает понять, насколько компания инвестирует в развитие сотрудников и поддерживает ли непрерывное повышение квалификации внутри организации.'
            },
            {
            id: 'accordion_hr_q3',
            title: 'Будет ли свое место в офисе? Или только коворкинг?',
            answer: 'Проясняет формат рабочего пространства и степень комфорта для эффективной долгосрочной работы сотрудника.'
            },
            {
            id: 'accordion_hr_q4',
            title: 'Трудоустройство в компанию или в дочку?',
            answer: 'Позволяет уточнить юридическое лицо, в котором будет оформлен сотрудник, и связанные с этим условия труда и соцгарантии.'
            },
            {
            id: 'accordion_hr_q5',
            title: 'Будут ли ограничения при устройстве в дочку? (Пропуски, премии, доступ к АС)',
            answer: 'Нужен для понимания, какие привилегии и бонусы сохранятся или изменятся при оформлении в дочернюю структуру.'
            },
            {
            id: 'accordion_hr_q6',
            title: 'Почему предыдущий сотрудник оставил роль QA?',
            answer: 'Помогает выявить возможные сложности, с которыми сталкиваются на этой позиции, и понять масштаб ожидаемых задач.'
            },
            {
            id: 'accordion_hr_q7',
            title: 'Есть ли scrum-мастер в команде? Как часто проводится ретро?',
            answer: 'Уточняет уровень зрелости Agile-практик в команде и частоту ретроспектив, что влияет на динамику развития процессов.'
            },
            {
            id: 'accordion_hr_q8',
            title: 'Есть ли в команде совместные роли? (Например: ПО пишет аналитику)',
            answer: 'Позволяет понять, насколько гибко распределяются обязанности и возможен ли кросс-функциональный обмен навыками.'
            },
            {
            id: 'accordion_hr_q9',
            title: 'Есть в команде культура настольных игр, похода в бар?',
            answer: 'Нужен для оценки неформальной атмосферы внутри коллектива и мероприятий, способствующих сплочению команды.'
            },
            {
            id: 'accordion_hr_q10',
            title: 'Есть в команде чатики с неформальным общением (мемасики)?',
            answer: 'Помогает понять уровень дружеского общения и открытость внутри команды в повседневном общении.'
            },
            {
            id: 'accordion_hr_q11',
            title: 'Есть ли вектор развития проекта автотестов?',
            answer: 'Уточняет планы по автоматизации тестирования и перспективы развития этого направления в рамках проекта.'
            },
            {
            id: 'accordion_hr_q12',
            title: 'Сколько тестировщиков в команде и есть ли QA лид?',
            answer: 'Помогает оценить размер команды и структуру управления, чтобы понимать, какую поддержку и наставничество можно ожидать.'
            },
            {
            id: 'accordion_hr_q13',
            title: 'Есть ли конфликты в команде между сотрудниками?',
            answer: 'Позволяет оценить уровень командного климата и заранее узнать о потенциальных рисках, связанных с взаимодействием коллег.'
            },
            {
            id: 'accordion_hr_q14',
            title: 'Входит ли премия в обсуждаемый оклад?',
            answer: 'Может быть такое, что вы попросили 130к, а по итогу в месяц будете получать 120к + раз в год премия - 120тыс. По итогу с оклада взяли 10 тыс. в месяц и спустя 12 месяцев выплатили эти же деньги в качестве премии.'
            },
            {
            id: 'accordion_hr_q15',
            title: 'По каким конкретно KPI вы оцениваете работу?',
            answer: 'Важно понимать, какие метрики и результаты будут служить основой для оценки эффективности и принятия решений о развитии.'
            },
            {
            id: 'accordion_hr_q16',
            title: 'Как часто пересматривается заработная плата? Что для этого нужно сделать?',
            answer: 'Уточняет периодичность пересмотра компенсации и критерии, которые нужно выполнить для повышения уровня оплаты.'
            },
            {
            id: 'accordion_hr_q17',
            title: 'Есть ли оплата за переработки?',
            answer: 'Помогает выяснить, компенсируются ли сверхурочные часы и на каких условиях.'
            },
            {
            id: 'accordion_hr_q18',
            title: 'Есть ли переработки и с чем они связаны?',
            answer: 'Уточняет характер нагрузки и возможные причины, которые могут приводить к работе сверх нормы.'
            },
            {
            id: 'accordion_hr_q19',
            title: 'Будет ли испытательный срок?',
            answer: 'Нужен для понимания периода адаптации и проверки соответствия ожиданиям компании.'
            },
            {
            id: 'accordion_hr_q20',
            title: 'На время испытательного срока есть ли разница в заработной плате?',
            answer: 'Проясняет, изменится ли компенсация в период испытательного срока по сравнению с основной ставкой.'
            },
            {
            id: 'accordion_hr_q21',
            title: 'Что является критерием прохождения испытательного срока?',
            answer: 'Позволяет заранее узнать требования и цели, которые нужно будет достигнуть для успешного завершения испытания.'
            },
            {
            id: 'accordion_hr_q22',
            title: 'Сколько времени я буду получать доступы к технике/АС? Через сколько мне дадут реальные задачи?',
            answer: 'Уточняет сроки выдачи ресурсов и начала полноценной работы, что важно для планирования первого этапа вхождения в проект.'
            },
            {
            id: 'accordion_hr_q23',
            title: 'Есть ли полноценное обучение? Сколько времени оно занимает?',
            answer: 'Помогает узнать, предусмотрена ли структурированная программа обучения и как долго продлится погружение в процессы.'
            },
            {
            id: 'accordion_hr_q24',
            title: 'Будет ли у меня наставник/бадди на первое время?',
            answer: 'Проясняет наличие поддержки от опытного коллеги в период адаптации для более быстрого вхождения в роль.'
            },
            {
            id: 'accordion_hr_q25',
            title: 'Что конкретно я буду делать на данной должности? Что будет входить в мои обязанности?',
            answer: 'Нужен для чёткого понимания функционала, задач и зон ответственности, чтобы соотнести ожидания и реальную работу.'
            },
            {
            id: 'accordion_hr_q26',
            title: 'Кто будет моим непосредственным руководителем/ лидом?',
            answer: 'Уточняет, с кем вы будете взаимодействовать напрямую и кто будет отвечать за ваш профессиональный рост и поддержку.'
            },
            {
            id: 'accordion_hr_q27',
            title: 'Сколько человек сейчас работает в команде? Планируется ли расширение?',
            answer: 'Помогает оценить текущий масштаб проекта и перспективы роста команды в ближайшем будущем.'
            },
            {
            id: 'accordion_hr_q28',
            title: 'На данной должности есть рост в зарплате и в проф. навыках?',
            answer: 'Проясняет доступные пути развития карьеры и повышения квалификации вместе с компенсацией.'
            },
            {
            id: 'accordion_hr_q29',
            title: 'Какие еще будут этапы перед выходом на работу?',
            answer: 'Уточняет оставшиеся шаги процесса найма и адаптации, чтобы заранее подготовиться к каждому из них.'
            },
            {
            id: 'accordion_hr_q30',
            title: 'В каком формате вы даёте обратную связь кандидату?',
            answer: 'Помогает понять, получите ли вы конструктивный и детализированный фидбэк с указанием сильных и слабых сторон, а не общий отказ без конкретики, чтобы знать, над чем стоит поработать для будущих собеседований.'
            }
        ]
        },
        {
          category: 'AQA Java',
          items: [
            {
              id: 'accordion_aqajava_q1',
              title: 'Какие инструменты вы используете для автоматизации тестирования?',
              answer: 'Для Full Stack QA на Java обычно используется связка: сборка и зависимости — Maven или Gradle, юнит/компонентные тесты — JUnit или TestNG, UI — Selenium или Selenide, API — Rest Assured, отчеты — Allure, запуск в CI — Jenkins/GitLab CI/GitHub Actions. <br><br>Пример запуска смоук-набора через Maven: <br><br><code>mvn clean test -Dgroups=smoke<br># или через Gradle<br>./gradlew test -Dgroups=smoke</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q2',
              title: 'Какие существуют Java-фреймворки для автотестов?',
              answer: 'Для UI: Selenium WebDriver (базовый стандарт), Selenide (удобная надстройка с автоожиданиями). <br><br>Для API: Rest Assured, Retrofit + OkHttp. <br><br>Для BDD: Cucumber. <br><br>Для юнитов: JUnit, TestNG. <br><br>Пример теста на TestNG: <br><br><code>@Test<br>public void loginTest() {<br>  // шаги логина<br>  // проверки<br>}</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q3',
              title: 'Что такое интерфейсы и в каких случаях их следует использовать?',
              answer: 'Интерфейс — это контракт, который описывает набор методов без реализации. В автотестах интерфейсы удобны, когда нужно абстрагировать разные реализации клиентов или драйверов. <br><br>Пример: общий контракт для API-клиента: <br><br><code>public interface ApiClient {<br>  Response get(String url);<br>  Response post(String url, Object body);<br>}</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q4',
              title: 'Как Java обрабатывает исключения в автотестах?',
              answer: 'Через конструкцию try-catch или проброс исключений выше. В тестах это используется для логирования, скриншотов, сохранения HTML страницы, чтобы было видно причину падения. <br><br>Пример: <br><br><code>try {<br>  loginPage.submit();<br>} catch (TimeoutException e) {<br>  takeScreenshot();<br>  throw e;<br>}</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q5',
              title: 'Как организовать тестовые сценарии на Java?',
              answer: 'Тестовые сценарии оформляют как методы в тестовых классах. Действия и локаторы выносятся в Page Object, а API-вызовы — в отдельные клиенты. Для данных используют фикстуры или DataProvider. <br><br>Пример структуры: <br><br><code>LoginPage loginPage = new LoginPage(driver);<br>loginPage.login("qa", "123");<br>assertTrue(dashboard.isVisible());</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q6',
              title: 'В чём отличие микросервисов от монолита в тестировании?',
              answer: 'В микросервисах чаще используют контрактные и интеграционные тесты для каждого сервиса отдельно, а также проверяют взаимодействия между сервисами. В монолитах больше UI и сквозных сценариев, потому что логика сосредоточена в одном приложении. <br><br>Пример: для микросервиса оплаты отдельно тестируется API, а для монолита — единая цепочка заказа через UI.',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q7',
              title: 'Назовите отличительные характеристики тестирования API',
              answer: 'API-тесты не зависят от интерфейса, быстрее UI, дают стабильные проверки бизнес-логики и интеграций. Для Full Stack QA это основной слой тестовой пирамиды. <br><br>Пример проверки Rest Assured: <br><br><code>given()<br>  .when().get("/users/1")<br>  .then().statusCode(200)<br>  .body("id", equalTo(1));</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q8',
              title: 'Какие основные отличия между тестированием API и GUI?',
              answer: 'API-тесты проверяют правильность контрактов, статусов, схем данных и бизнес-правил. GUI-тесты проверяют клиентский путь, отображение элементов и UX. <br><br>Пример: API проверяет, что заказ создаётся, а GUI — что заказ отображается в личном кабинете.',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q9',
              title: 'Чем отличаются Selenium, Selenide, Playwright и Cypress?',
              answer: 'Selenium — базовый стандарт WebDriver. Selenide — удобная надстройка над Selenium с автоожиданиями. Playwright и Cypress дают быстрые раннеры и более простую работу с асинхронностью. Playwright поддерживает несколько браузеров, включая WebKit. <br><br>Пример Selenide: <br><br><code>$("#login").setValue("qa");<br>$("#password").setValue("123");<br>$("#submit").click();</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q10',
              title: 'Что такое Page Object?',
              answer: 'Page Object — паттерн, где элементы страницы и действия с ними вынесены в отдельный класс. Это снижает дублирование и упрощает поддержку тестов. <br><br>Пример: <br><br><code>public class LoginPage {<br>  public void login(String user, String pass) { /* шаги */ }<br>}</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q11',
              title: 'Можете ли вы объяснить принцип работы Page Factory?',
              answer: 'Page Factory автоматически инициализирует элементы страницы по аннотациям @FindBy. Это уменьшает ручную работу с локаторами. <br><br>Пример: <br><br><code>@FindBy(id = "login")<br>private WebElement login;<br><br>public void enterLogin(String value) {<br>  login.sendKeys(value);<br>}</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q12',
              title: 'Что такое Allure и для чего он используется?',
              answer: 'Allure — инструмент для отчетов. Он показывает шаги, вложения (скриншоты, логи), историю запусков. В Full Stack QA это удобно для анализа падений в CI. <br><br>Пример: <br><br><code>Allure.step("Отправить запрос на /login");</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q13',
              title: 'Как интегрировать автотесты в CI/CD?',
              answer: 'Тесты запускаются на каждый коммит/мерж. Быстрые смоук/апи — в PR, UI и регресс — nightly. Результаты складываются в отчеты и артефакты. <br><br>Пример команды: <br><br><code>mvn test -Dgroups=smoke<br>mvn test -Dgroups=ui</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q14',
              title: 'Какие существуют принципы ООП?',
              answer: 'Инкапсуляция, наследование, полиморфизм, абстракция. В тестах это помогает сделать повторно используемые базовые страницы, клиенты и утилиты. <br><br>Пример: <br><br><code>public abstract class BasePage {<br>  protected WebDriver driver;<br>}</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q15',
              title: 'В чем разница между интерфейсом и абстрактным классом?',
              answer: 'Интерфейс задает контракт без состояния, абстрактный класс может хранить поля и реализовывать общие методы. В тестах удобно иметь абстрактный BasePage и интерфейсы для общих действий. <br><br>Пример: <br><br><code>public interface Clickable {<br>  void click();<br>}<br><br>public abstract class BasePage {<br>  protected WebDriver driver;<br>}</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q16',
              title: 'Какие существуют модификаторы доступа?',
              answer: 'public, protected, default, private. Для тестов часто делают локаторы private, а действия — public. <br><br>Пример: <br><br><code>private By login = By.id("login");<br>public void enterLogin(String value) { /* ... */ }</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q17',
              title: 'О чем говорит ключевое слово final?',
              answer: 'final фиксирует значение переменной или запрещает наследование класса/переопределение метода. В тестах удобно для констант и базовых URL. <br><br>Пример: <br><br><code>private static final String BASE_URL = "https://site";</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q18',
              title: 'Какие логические операции и операторы вы знаете?',
              answer: '&&, ||, !, ==, !=, >, <, >=, <= и др. В тестах используются в ассертах и проверках. <br><br>Пример: <br><br><code>assertTrue(status == 200 && body.contains("ok"));</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q19',
              title: 'Что такое REST Assured?',
              answer: 'REST Assured — библиотека для API-автотестов на Java. Позволяет писать проверки в стиле given/when/then. <br><br>Пример: <br><br><code>given()<br>  .body(payload)<br>  .post("/login")<br>  .then().statusCode(200);</code>',
              moreLink: 'https://www.youtube.com/watch?v=8nAgzJea1L8'
            },
            {
              id: 'accordion_aqajava_q20',
              title: 'Как отличить стабильный UI-локатор от хрупкого?',
              answer: 'Стабильные локаторы — data-testid, aria-label, фиксированные id. Хрупкие — по тексту или по сложной иерархии DOM. <br><br>Пример: <br><br><code>By.cssSelector("[data-testid="submit"]")</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q21',
              title: 'Имплицитные и эксплицитные ожидания: в чем разница?',
              answer: 'Implicit Wait задается глобально для всех локаторов. Explicit Wait применяется точечно к конкретному условию, обычно более надежен. <br><br>Пример: <br><br><code>WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));<br>wait.until(ExpectedConditions.visibilityOf(element));</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q22',
              title: 'Как делать data-driven тесты в TestNG?',
              answer: 'Использовать @DataProvider и параметризовать тесты данными. <br><br>Пример: <br><br><code>@DataProvider<br>public Object[][] users() {<br>  return new Object[][]{{"admin","123"},{"user","qwe"}};<br>}<br><br>@Test(dataProvider = "users")<br>public void login(String u, String p) { /* ... */ }</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q23',
              title: 'Как проверять JSON в ответе API?',
              answer: 'В Rest Assured удобно использовать JSONPath и матчеры, а также проверять схему. <br><br>Пример: <br><br><code>then()<br>  .body("user.id", equalTo(1))<br>  .body("user.role", equalTo("ADMIN"));</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q24',
              title: 'Как бороться с флаппи-тестами?',
              answer: 'Убирать Thread.sleep, использовать явные ожидания, стабилизировать локаторы, изолировать данные, добавлять логи и скрины. Повторный запуск допустим только для диагностики. <br><br>Пример: заменить <code>Thread.sleep(3000)</code> на Explicit Wait.',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q25',
              title: 'Как организовать уровни тестов для Full Stack QA?',
              answer: 'Тестовая пирамида: много API/интеграционных тестов, меньше UI и минимум end-to-end. Это дает стабильность и скорость. <br><br>Пример: API-smoke на каждый PR, UI-регресс nightly.',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q26',
              title: 'Как хранить тестовые данные и секреты?',
              answer: 'Данные — в json/yaml или базе тестовых данных, секреты — в переменных окружения или секрет-хранилищах CI. <br><br>Пример: <br><br><code>String token = System.getenv("TOKEN");</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajava_q27',
              title: 'Как валидировать данные в БД после API-операции?',
              answer: 'После API-запроса можно подключиться к базе и проверить, что запись появилась или изменилась статус. Это полезно для Full Stack QA, когда важно проверить интеграцию сервиса и БД. <br><br>Пример JDBC: <br><br><code>Connection c = DriverManager.getConnection(url, user, pass);<br>PreparedStatement st = c.prepareStatement("SELECT status FROM orders WHERE id=?");<br>st.setInt(1, id);<br>ResultSet rs = st.executeQuery();<br>// assert по статусу</code>',
              moreLink: ''
            }
        ]
        },
        {
category: 'AQA Python',
          items: [
            {
              id: 'accordion_aqapython_q1',
              title: 'Какие Python-фреймворки для тестирования вы знаете?',
              answer: 'Для автоматизации в Python чаще всего используют pytest (основной стандарт), unittest (базовый модуль), Robot Framework и Behave для BDD. Для UI — Playwright или Selenium, для API — requests + pytest. <br><br>Пример запуска smоke: <br><br><code>pytest -m smoke</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q2',
              title: 'Что такое кортежи (tuple) и где они полезны в тестах?',
              answer: 'Кортеж — неизменяемая последовательность. Удобен как контейнер тестовых наборов, чтобы случайно не изменить данные в процессе теста. <br><br>Пример: <br><br><code>cases = (<br>  ("admin", "123"),<br>  ("user", "qwe")<br>)</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q3',
              title: 'Какие существуют правила наименования в Python?',
              answer: 'Переменные — snake_case, классы — PascalCase, константы — UPPER_CASE. Это важно для читаемости тестов. <br><br>Пример: <br><br><code>BASE_URL = "https://api"<br>class LoginPage:<br>    pass</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q4',
              title: 'Что такое unittest одной фразой?',
              answer: 'Это стандартный модуль Python для написания юнит-тестов с классами, setUp/tearDown и ассертом. <br><br>Пример: <br><br><code>import unittest<br><br>class TestLogin(unittest.TestCase):<br>    def test_login(self):<br>        self.assertTrue(True)</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q5',
              title: 'Как конвертировать число в строку?',
              answer: 'Через функцию str(). Это часто используется при формировании параметров запроса. <br><br>Пример: <br><br><code>user_id = 10<br>url = "/users/" + str(user_id)</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q6',
              title: 'Какие задачи Python решает в тестировании?',
              answer: 'Python используют для API- и UI-автотестов, генерации данных, работы с логами, создания утилит для CI/CD. Он удобен из-за лаконичного синтаксиса и огромной экосистемы. <br><br>Пример API-проверки: <br><br><code>import requests<br><br>r = requests.get("/health")<br>assert r.status_code == 200</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q7',
              title: 'Неизменяемые типы данных в Python?',
              answer: 'int, float, str, tuple, bool, frozenset. В тестах часто используют для констант. <br><br>Пример: <br><br><code>STATUSES = (200, 201, 204)</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q8',
              title: 'Что такое фикстуры pytest и зачем нужны?',
              answer: 'Фикстуры подготавливают окружение, тестовые данные и клиентов. Это упрощает поддержку и уменьшает дублирование. <br><br>Пример: <br><br><code>@pytest.fixture<br>def token():<br>    return login()</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q9',
              title: 'Как параметризовать тесты в pytest?',
              answer: 'Использовать @pytest.mark.parametrize, чтобы прогонять тест на разных входных данных. <br><br>Пример: <br><br><code>@pytest.mark.parametrize("user,code", [<br>    ("admin", 200),<br>    ("guest", 403)<br>])<br>def test_access(user, code):<br>    pass</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q10',
              title: 'Как проверить JSON-ответ API в Python?',
              answer: 'Делаем запрос, вызываем json(), проверяем ключи. Можно использовать pydantic/JSON schema для валидации. <br><br>Пример: <br><br><code>r = requests.get("/users/1")<br>data = r.json()<br>assert data["id"] == 1</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q11',
              title: 'Как запускать UI и API тесты в одном пайплайне?',
              answer: 'Разделять по маркерам: api — быстрые проверки в PR, ui — ночной прогон. Это оптимально для Full Stack QA. <br><br>Пример: <br><br><code>pytest -m api<br>pytest -m ui</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q12',
              title: 'Как работать с ожиданиями в Playwright (Python)?',
              answer: 'Playwright имеет автоожидания, но можно использовать явные ожидания для сложных условий. <br><br>Пример: <br><br><code>page.goto(url)<br>page.wait_for_selector("#login")<br>page.fill("#login", "qa")</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q13',
              title: 'Как бороться с флаппи-тестами в Python?',
              answer: 'Убирать sleep, использовать ожидания, стабилизировать локаторы, изолировать тестовые данные, сохранять логи и видео. <br><br>Пример: заменить time.sleep на ожидание элемента.',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q14',
              title: 'Как хранить секреты и конфиги в Python-тестах?',
              answer: 'Использовать env переменные или отдельные конфиги для сред. В CI секреты — через vault/секрет-менеджер. <br><br>Пример: <br><br><code>import os<br>TOKEN = os.getenv("TOKEN")</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqapython_q15',
              title: 'Как проверить данные в БД после теста?',
              answer: 'Подключаемся к БД (psycopg2/SQLAlchemy), делаем запрос, сверяем результат. Это важно для Full Stack QA. <br><br>Пример: <br><br><code>cur.execute("SELECT status FROM orders WHERE id=%s", (order_id,))<br>assert cur.fetchone()[0] == "PAID"</code>',
              moreLink: ''
            }
        ]
        },
        {
category: 'AQA JS',
          items: [
            {
              id: 'accordion_aqajs_q1',
              title: 'Что такое NodeJS и зачем он QA-автоматизатору?',
              answer: 'Node.js позволяет запускать JS вне браузера и использовать тест-раннеры (Playwright, Cypress). Это удобно для Full Stack QA, потому что можно тестировать UI и API одной средой. <br><br>Пример: <br><br><code>npx playwright test</code>',
              moreLink: 'https://doka-guide.vercel.app/tools/nodejs/'
            },
            {
              id: 'accordion_aqajs_q2',
              title: 'Основные типы данных в JavaScript?',
              answer: 'Примитивы: number, string, boolean, null, undefined, symbol, bigint. Объекты: object (включая массивы и функции). В тестах это важно при сравнении и валидации данных. <br><br>Пример: <br><br><code>const ids = [<br>  1,<br>  2,<br>  3<br>];</code>',
              moreLink: 'https://codechick.io/tutorials/javascript/js-data-types'
            },
            {
              id: 'accordion_aqajs_q3',
              title: 'Разница между == и ===?',
              answer: '== приводит типы, === сравнивает строго. В тестах лучше использовать строгое сравнение, чтобы избежать ложных совпадений. <br><br>Пример: <br><br><code>console.log(5 == "5");  // true<br>console.log(5 === "5"); // false</code>',
              moreLink: 'https://habr.com/ru/articles/138272/'
            },
            {
              id: 'accordion_aqajs_q4',
              title: 'Что такое конструкция switch-case?',
              answer: 'switch-case — конструкция для выбора ветки по значению. Полезна, когда в тестах нужно обрабатывать несколько состояний ответа. <br><br>Пример: <br><br><code>const day = 3;<br>switch (day) {<br>  case 1:<br>    break;<br>  case 2:<br>    break;<br>  default:<br>    break;<br>}</code>',
              moreLink: 'https://learn.javascript.ru/switch',
              authorCheck: 'https://t.me/QAtoDev',
              avatar: 'img/QAtoDev_PageIcon.png'
            },
            {
              id: 'accordion_aqajs_q5',
              title: 'Что такое async/await и зачем это QA в UI/API тестах?',
              answer: 'Async/await делает асинхронный код читаемым. В UI/API тестах это основа: запросы, ожидания элементов, загрузка страниц. <br><br>Пример: <br><br><code>const res = await request.get("/users/1");<br>expect(res.status()).toBe(200);</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajs_q6',
              title: 'Cypress или Playwright: когда что выбрать?',
              answer: 'Cypress удобен для UI и быстрых e2e, но ограничен Chromium. Playwright подходит для кроссбраузерности и сложных сценариев (Safari/WebKit). <br><br>Пример: Playwright позволяет запускать один и тот же тест в Chromium, Firefox и WebKit.',
              moreLink: ''
            },
            {
              id: 'accordion_aqajs_q7',
              title: 'Как тестировать API в JS-автотестах?',
              answer: 'Можно использовать встроенный request в Playwright или axios/fetch. Проверяем статус и тело ответа. <br><br>Пример: <br><br><code>const r = await request.get("/health");<br>expect(r.status()).toBe(200);<br>const body = await r.json();</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajs_q8',
              title: 'Что такое network intercept и зачем он?',
              answer: 'Интерсепт позволяет мокать ответы API и проверять, какие запросы отправляет UI. Это делает тесты стабильнее. <br><br>Пример: <br><br><code>await page.route("**/api/**", route =><br>  route.fulfill({ status: 200, body: "{}" })<br>);</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajs_q9',
              title: 'Как выбирать стабильные локаторы?',
              answer: 'Использовать data-testid и aria-label. Избегать хрупких селекторов по структуре DOM. <br><br>Пример: <br><br><code>page.locator("[data-testid=\"submit\"]")</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajs_q10',
              title: 'Как устроить запуск тестов в CI/CD?',
              answer: 'Запускать тесты на коммит/PR, хранить отчеты и артефакты. Для UI часто сохраняют скрины/видео. <br><br>Пример: <br><br><code>npx playwright test --reporter=html</code>',
              moreLink: ''
            },
            {
              id: 'accordion_aqajs_q11',
              title: 'Как бороться с флаппи-тестами в JS?',
              answer: 'Убирать sleep, использовать автоожидания, стабилизировать селекторы, изолировать данные. Полезно сохранять трассы и видео. <br><br>Пример: заменить <code>page.waitForTimeout</code> на ожидание локатора.',
              moreLink: ''
            },
            {
              id: 'accordion_aqajs_q12',
              title: 'Что такое тестовая пирамида для Full Stack QA?',
              answer: 'Основа — API/интеграционные тесты, далее UI, на вершине немного E2E. Такой подход дает скорость и стабильность. <br><br>Пример: API-smoke на каждый PR, UI — nightly.',
              moreLink: ''
            },
            {
              id: 'accordion_aqajs_q13',
              title: 'Как валидировать данные в БД из JS-тестов?',
              answer: 'Можно подключаться через pg/mysql2 и сверять данные после API-операции. Это часто требуется Full Stack QA. <br><br>Пример: <br><br><code>const client = new Client(cfg);<br>await client.connect();<br>const res = await client.query(<br>  "SELECT status FROM orders WHERE id=$1",<br>  [id]<br>);</code>',
              moreLink: ''
            }
        ]
        }
      ];
      const localQuestionsData = data;
      let runtimeQuestionsData = [];
      window.questionsDataLocal = localQuestionsData; // локальный источник для диагностики
      window.questionsData = runtimeQuestionsData; // активный источник для рендера


  const IO_API_BASE = "https://api.intelligence.io.solutions/api/v1";
  const IO_API_KEY = (() => {
    const p1 = "io-v2-eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.";
    const p2 = "eyJvd25lciI6IjVhNzhhY2I4LTJkZmUtNGRiNi04N2QxLTkxODZmNTFmZDllZSIsImV4cCI6NDkyNDc3MTU3OH0.";
    const p3 = "EMXKUEfcMvAbtMt_WodTcNcENyqOXwfuF16wtC4-8i2sJgak6KJODACg3c3tyzwjbacXC1XHUu3jS9E4C14VLw";
    return p1 + p2 + p3;
  })();
  const OVERRIDE_API_KEY_STORAGE = "io_api_key_override";
  const SUPABASE_URL_DIRECT = "https://mbebpfbmnojlaggdroum.supabase.co";
  const SUPABASE_ANON_KEY_DIRECT = "sb_publishable_T3nVktglpWOrhAtjsYQggw_2ywfFs8C";
  const DEFAULT_MODEL = "openai/gpt-oss-20b";
  const FAST_MODEL_HINTS = [
    "openai/gpt-oss-20b",
    "mistralai/Mistral-Nemo-Instruct-2407",
    "meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8",
    "moonshotai/Kimi-K2-Instruct-0905",
    "deepseek-ai/DeepSeek-V3.2"
  ];
  const AI_LOADER_HTML = '<span class="ai-loader"><span class="ai-spinner"></span><span class="ai-loader-text">Сейчас модель вернет ответ</span></span>';
  let currentModels = FAST_MODEL_HINTS.slice(0, 5);
  const MODEL_TIMINGS_KEY = "model_timings_v1";
  const MODEL_FAILURES_KEY = "model_failures_v1";
  const MODEL_WARMUP_KEY = "model_warmup_ts_v1";
  const MODEL_LIST_CACHE_KEY = "model_list_cache_v1";
  const MODEL_LIST_CACHE_TTL_MS = 6 * 60 * 60 * 1000;
  const QUESTIONS_CACHE_KEY = "questions_db_cache_v1";
  const QUESTIONS_CACHE_TTL_MS = 24 * 60 * 60 * 1000;
  const AI_SUPPLEMENT_META_KEY = "ai_supplement_meta_v1";
  const AI_RESPONSES_LOCAL_PREFIX = "ai_responses_";
  const AI_SUPPLEMENT_MAX = 4;
  let modelListFromCache = false;
  let pendingRetry = null;

  // --- UI elements: поиск, AI, переключатель модели ---
  const searchInput    = document.getElementById("search-input");
  const modelsListEl   = document.getElementById("ai-models-list");
  const clearBtn       = document.getElementById("search-clear-btn");
  const resultsTitle   = document.getElementById("search-results-title");
  const about          = document.getElementById("about");
  const apiKeyModal    = document.getElementById("api-key-modal");
  const apiKeyInput    = document.getElementById("api-key-input");
  const apiKeySave     = document.getElementById("api-key-save");
  const apiKeyClose    = document.getElementById("api-key-close");
  const authOpenBtn    = document.getElementById("auth-open-btn");
  const authModal      = document.getElementById("auth-modal");
  const authCard       = authModal?.querySelector(".auth-card");
  const authTitle      = document.getElementById("auth-title");
  const authDescription = document.getElementById("auth-description");
  const authLevelWrap  = document.getElementById("auth-level-wrap");
  const authTrackSelect = document.getElementById("auth-track-select");
  const authGradeSelect = document.getElementById("auth-grade-select");
  const authOAuthRow    = document.getElementById("auth-oauth-row");
  const authGoogleBtn   = document.getElementById("auth-google-btn");
  const authEmailToggle = document.getElementById("auth-email-toggle");
  const authEmailInput = document.getElementById("auth-email-input");
  const authSyncBtn    = document.getElementById("auth-sync-btn");
  const authSendBtn    = document.getElementById("auth-send-btn");
  const authCloseBtn   = document.getElementById("auth-close-btn");
  const authStatus     = document.getElementById("auth-status");
  const supabaseStore  = window.AppSupabase || null;
  let authUser = null;
  let authProfile = null;
  let authEmailLoginExpanded = false;
  const AUTH_PENDING_PROFILE_KEY = "auth_pending_profile_v1";
  const CLOUD_SYNC_TS_KEY = "cloud_sync_ts_v1";
  const PENDING_MUTATIONS_KEY = "cloud_pending_mutations_v1";
  const CLOUD_SYNC_TTL_MS = 60 * 1000;
  const CLOUD_OP_TIMEOUT_MS = 10000;
  const REST_TIMEOUT_MS = 7000;
  const cloudProgressByQuestion = new Map();
  const cloudAnswersByQuestion = new Map();
  const aiItemState = new Map();
  let cloudSyncPromise = null;

  function readModelListCache() {
    try {
      const raw = localStorage.getItem(MODEL_LIST_CACHE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.models) || !parsed.ts) return null;
      if ((Date.now() - parsed.ts) > MODEL_LIST_CACHE_TTL_MS) return null;
      return parsed.models;
    } catch {
      return null;
    }
  }

  function readQuestionsCache() {
    try {
      const raw = localStorage.getItem(QUESTIONS_CACHE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.data) || !parsed.ts) return null;
      if ((Date.now() - parsed.ts) > QUESTIONS_CACHE_TTL_MS) return null;
      return parsed.data;
    } catch {
      return null;
    }
  }

  function writeQuestionsCache(data) {
    try {
      safeSetItemWithAiEviction(QUESTIONS_CACHE_KEY, JSON.stringify({
        ts: Date.now(),
        data
      }));
    } catch {}
  }

  function writeModelListCache(models) {
    try {
      safeSetItemWithAiEviction(MODEL_LIST_CACHE_KEY, JSON.stringify({
        ts: Date.now(),
        models
      }));
    } catch {}
  }

  function isQuotaExceededError(err) {
    return !!err && (
      err.name === "QuotaExceededError" ||
      err.code === 22 ||
      String(err.message || "").toLowerCase().includes("quota")
    );
  }

  function readAiSupplementMeta() {
    try {
      const raw = localStorage.getItem(AI_SUPPLEMENT_META_KEY);
      const parsed = JSON.parse(raw || "[]");
      return Array.isArray(parsed) ? parsed : [];
    } catch {
      return [];
    }
  }

  function writeAiSupplementMeta(meta) {
    try {
      localStorage.setItem(AI_SUPPLEMENT_META_KEY, JSON.stringify(meta));
      return true;
    } catch (e) {
      console.warn("Failed to write AI supplement meta", e);
      return false;
    }
  }

  function evictOldestAiSupplement(excludeKey) {
    const meta = readAiSupplementMeta()
      .filter(x => x && x.key && x.key !== excludeKey)
      .sort((a, b) => (a.ts || 0) - (b.ts || 0));
    if (!meta.length) return false;
    const oldest = meta[0];
    try {
      localStorage.removeItem(oldest.key);
    } catch {}
    const nextMeta = readAiSupplementMeta().filter(x => x && x.key && x.key !== oldest.key);
    writeAiSupplementMeta(nextMeta);
    return true;
  }

  function safeSetItemWithAiEviction(key, value, excludeAiKey) {
    try {
      localStorage.setItem(key, value);
      return true;
    } catch (e) {
      if (!isQuotaExceededError(e)) {
        console.warn(`setItem failed for ${key}`, e);
        return false;
      }
      while (evictOldestAiSupplement(excludeAiKey)) {
        try {
          localStorage.setItem(key, value);
          return true;
        } catch (retryErr) {
          if (!isQuotaExceededError(retryErr)) {
            console.warn(`setItem retry failed for ${key}`, retryErr);
            return false;
          }
        }
      }
      return false;
    }
  }

  function saveAiSupplementWithLimit(key, payload) {
    const value = JSON.stringify(payload);
    const written = safeSetItemWithAiEviction(key, value, key);
    if (!written) return false;

    let meta = readAiSupplementMeta().filter(x => x && x.key && x.key !== key);
    meta.push({ key, ts: Date.now() });
    meta.sort((a, b) => (b.ts || 0) - (a.ts || 0));

    const toRemove = meta.slice(AI_SUPPLEMENT_MAX);
    toRemove.forEach(item => {
      try {
        localStorage.removeItem(item.key);
      } catch {}
    });
    meta = meta.slice(0, AI_SUPPLEMENT_MAX);
    writeAiSupplementMeta(meta);
    return true;
  }

  function getAuthKey() {
    const override = localStorage.getItem(OVERRIDE_API_KEY_STORAGE);
    return (override && override.trim()) ? override.trim() : IO_API_KEY;
  }

  function showApiKeyModal() {
    if (!apiKeyModal) return;
    apiKeyModal.classList.add("show");
    apiKeyModal.setAttribute("aria-hidden", "false");
    if (apiKeyInput) {
      apiKeyInput.value = localStorage.getItem(OVERRIDE_API_KEY_STORAGE) || "";
      apiKeyInput.focus();
    }
  }

  function hideApiKeyModal() {
    if (!apiKeyModal) return;
    apiKeyModal.classList.remove("show");
    apiKeyModal.setAttribute("aria-hidden", "true");
  }

  function isCloudReady() {
    return !!(supabaseStore && supabaseStore.client);
  }

  function setAuthStatus(message) {
    if (authStatus) authStatus.textContent = message || "";
  }

  function readPendingProfile() {
    try {
      return JSON.parse(localStorage.getItem(AUTH_PENDING_PROFILE_KEY) || "null");
    } catch {
      return null;
    }
  }

  function writePendingProfile(profile) {
    try {
      localStorage.setItem(AUTH_PENDING_PROFILE_KEY, JSON.stringify(profile));
    } catch {}
  }

  function clearPendingProfile() {
    try {
      localStorage.removeItem(AUTH_PENDING_PROFILE_KEY);
    } catch {}
  }

  function profileLabel(profile) {
    if (!profile?.track || !profile?.grade) return "";
    return `${profile.track} (${profile.grade})`;
  }

  function setEmailLoginExpanded(next) {
    authEmailLoginExpanded = !!next;
    if (authModal) authModal.classList.toggle("auth-email-expanded", authEmailLoginExpanded);
    if (authEmailToggle) authEmailToggle.setAttribute("aria-expanded", authEmailLoginExpanded ? "true" : "false");
  }

  function syncProfileUiFromState() {
    if (authTrackSelect && authProfile?.track) authTrackSelect.value = authProfile.track;
    if (authGradeSelect && authProfile?.grade) authGradeSelect.value = authProfile.grade;
    if (!authTitle) return;
    const label = profileLabel(authProfile);
    authTitle.textContent = label || "Сохранение прогресса";
  }

  async function applyPendingProfileToCloud() {
    if (!authUser || !supabaseStore?.upsertUserProfile) return false;
    const pending = readPendingProfile();
    if (!pending?.track || !pending?.grade) return false;
    const payload = {
      user_id: authUser.id,
      email: authUser.email || pending.email || null,
      track: pending.track,
      grade: pending.grade,
      updated_at: new Date().toISOString()
    };
    const { data: saved, error } = await supabaseStore.upsertUserProfile(payload);
    if (error) {
      console.warn("Failed to upsert pending user profile", error);
      return false;
    }
    authProfile = saved || payload;
    clearPendingProfile();
    syncProfileUiFromState();
    return true;
  }

  function applyAuthModalMode() {
    if (!authModal || !authEmailInput || !authSendBtn || !authCloseBtn) return;
    if (authModal.classList.contains("auth-checking")) return;
    const isAuthorized = !!authUser;
    const compactAuthorized = isAuthorized;
    authModal.classList.toggle("compact-auth", compactAuthorized);
    if (compactAuthorized) {
      if (authDescription) authDescription.style.display = "none";
      if (authLevelWrap) authLevelWrap.style.display = "none";
      if (authOAuthRow) authOAuthRow.style.display = "none";
      if (authEmailToggle) authEmailToggle.style.display = "none";
      authEmailInput.style.display = "none";
      if (authSyncBtn) authSyncBtn.style.display = "inline-flex";
      authSendBtn.textContent = "Выйти";
      authSendBtn.disabled = false;
      authSendBtn.style.display = "";
      syncProfileUiFromState();
      return;
    }
    if (authTitle) authTitle.textContent = "Сохранение прогресса";
    if (authDescription) authDescription.style.display = "";
    if (authLevelWrap) authLevelWrap.style.display = "";
    if (authOAuthRow) authOAuthRow.style.display = "";
    if (authEmailToggle) authEmailToggle.style.display = "";
    authEmailInput.style.display = authEmailLoginExpanded ? "" : "none";
    if (authSyncBtn) authSyncBtn.style.display = "none";
    authSendBtn.textContent = "Получить ссылку";
    authSendBtn.style.display = authEmailLoginExpanded ? "" : "none";
    authCloseBtn.textContent = "Закрыть";
  }

  function updateAuthButtonLabel() {
    if (!authOpenBtn) return;
    if (authUser?.email) {
      authOpenBtn.title = `Синхронизация: ${authUser.email}`;
      authOpenBtn.classList.add("is-auth");
      return;
    }
    authOpenBtn.title = "Войти и сохранить прогресс";
    authOpenBtn.classList.remove("is-auth");
  }

  function positionAuthModal() {
    if (!authModal || !authCard || !authOpenBtn) return;
    const trigger = authOpenBtn.getBoundingClientRect();
    const isMobile = window.innerWidth <= 600;
    const approxW = isMobile
      ? Math.min(268, Math.floor(window.innerWidth * 0.82))
      : Math.min(330, Math.floor(window.innerWidth * 0.8));
    const measuredW = authCard.offsetWidth || approxW;
    let left = Math.min(
      Math.max(8, trigger.right - measuredW),
      window.innerWidth - measuredW - 8
    );
    let top = trigger.bottom + 8;
    authCard.style.right = "auto";
    authCard.style.left = `${Math.max(8, left)}px`;
    authCard.style.top = `${Math.max(8, top)}px`;
    requestAnimationFrame(() => {
      const rect = authCard.getBoundingClientRect();
      if (isMobile) {
        left = Math.max(8, window.innerWidth - rect.width - 8);
      }
      if (rect.right > window.innerWidth - 8) {
        left = Math.max(8, window.innerWidth - rect.width - 8);
      }
      if (rect.left < 8) left = 8;
      if (rect.bottom > window.innerHeight - 8) {
        top = Math.max(8, window.innerHeight - rect.height - 8);
      }
      authCard.style.left = `${left}px`;
      authCard.style.top = `${top}px`;
      authCard.style.right = "auto";
    });
  }

  function showAuthModal(prefillMessage) {
    if (!authModal) return;
    setEmailLoginExpanded(false);
    if (!authUser) {
      const pending = readPendingProfile();
      if (authTrackSelect && pending?.track) authTrackSelect.value = pending.track;
      if (authGradeSelect && pending?.grade) authGradeSelect.value = pending.grade;
    }
    applyAuthModalMode();
    authModal.classList.add("show");
    authModal.setAttribute("aria-hidden", "false");
    positionAuthModal();
    setAuthStatus(prefillMessage || "");
    if (authEmailInput && authEmailLoginExpanded && authEmailInput.style.display !== "none") {
      authEmailInput.focus();
    }
  }

  function hideAuthModal() {
    if (!authModal) return;
    authModal.classList.remove("show");
    authModal.setAttribute("aria-hidden", "true");
    setAuthStatus("");
  }

  function getCleanRedirectUrl() {
    return `${window.location.origin}${window.location.pathname}`;
  }

  async function getActiveSession() {
    if (!isCloudReady()) return null;
    try {
      if (supabaseStore?.getSession) {
        const session = await withTimeout(supabaseStore.getSession(), 3000, "get session");
        if (session?.access_token) return session;
      }
      const fallback = await withTimeout(
        supabaseStore.client?.auth?.getSession?.() || Promise.resolve({ data: { session: null } }),
        3000,
        "get session fallback"
      );
      return fallback?.data?.session || null;
    } catch {
      return null;
    }
  }

  async function refreshAuthUser() {
    if (!isCloudReady()) return null;
    try {
      const session = await getActiveSession();
      if (!session?.access_token) {
        authUser = null;
        authProfile = null;
        updateAuthButtonLabel();
        return null;
      }
      authUser = await supabaseStore.getUser();
      if (authUser) {
        const { data } = await supabaseStore.getUserProfile(authUser.id);
        authProfile = data || null;
        await applyPendingProfileToCloud();
        syncProfileUiFromState();
      } else {
        authProfile = null;
      }
      updateAuthButtonLabel();
      return authUser;
    } catch (e) {
      console.warn("Supabase auth init failed", e);
      authUser = null;
      authProfile = null;
      updateAuthButtonLabel();
      return null;
    }
  }

  async function loadCloudProgress() {
    cloudProgressByQuestion.clear();
    if (!isCloudReady() || !authUser) return;
    try {
      const data = await restRequest("question_progress", {
        method: "GET",
        query: `select=user_id,question_id,status,updated_at&user_id=eq.${encodeURIComponent(authUser.id)}`
      });
      (data || []).forEach(row => {
        if (row?.question_id && row?.status) {
          cloudProgressByQuestion.set(row.question_id, row.status);
        }
      });
    } catch (e) {
      console.warn("Failed to load question progress from Supabase", e);
    }
  }

  async function loadCloudAnswers() {
    cloudAnswersByQuestion.clear();
    if (!isCloudReady() || !authUser) return;
    try {
      const data = await restRequest("ai_answers", {
        method: "GET",
        query: `select=id,question_id,answer_type,model,seconds,content,created_at&user_id=eq.${encodeURIComponent(authUser.id)}&order=created_at.asc`
      });
      (data || []).forEach(row => {
        if (!row?.question_id || !row?.content) return;
        const list = cloudAnswersByQuestion.get(row.question_id) || [];
        list.push({
          cloudId: row.id || null,
          answer: row.content,
          model: row.model || "",
          seconds: row.seconds || 0,
          arrivedAt: row.created_at ? Date.parse(row.created_at) || Date.now() : Date.now(),
          answerType: row.answer_type || "append"
        });
        cloudAnswersByQuestion.set(row.question_id, list);
      });
    } catch (e) {
      console.warn("Failed to load AI answers from Supabase", e);
    }
  }

  async function initializeCloudState() {
    await refreshAuthUser();
    if (!authUser) return;
    await syncLocalAndCloudState({ force: false, source: "init" });
  }

  function getCloudSyncLastTs() {
    return Number(localStorage.getItem(CLOUD_SYNC_TS_KEY) || 0);
  }

  function readPendingMutations() {
    try {
      const raw = localStorage.getItem(PENDING_MUTATIONS_KEY);
      const arr = JSON.parse(raw || "[]");
      return Array.isArray(arr) ? arr : [];
    } catch {
      return [];
    }
  }

  function writePendingMutations(mutations) {
    try {
      localStorage.setItem(PENDING_MUTATIONS_KEY, JSON.stringify(mutations.slice(-200)));
    } catch (e) {
      console.warn("Failed to persist pending mutations", e);
    }
  }

  function mutationKey(type, payload) {
    if (type === "saveProgress") return `${type}:${payload?.questionId}:${payload?.status}`;
    if (type === "saveAiAnswer") {
      const r = payload?.response || {};
      return `${type}:${payload?.questionId}:${payload?.answerType || r.answerType || "append"}:${r.model || ""}:${String(r.answer || "").slice(0, 200)}`;
    }
    if (type === "deleteAiById") return `${type}:${payload?.answerId}`;
    if (type === "deleteAiByPayload") {
      const r = payload?.response || {};
      return `${type}:${payload?.questionId}:${r.answerType || "append"}:${r.model || ""}:${String(r.answer || "").slice(0, 200)}`;
    }
    return `${type}:${Date.now()}`;
  }

  function enqueueMutation(type, payload) {
    const mutations = readPendingMutations();
    const key = mutationKey(type, payload);
    const existingIdx = mutations.findIndex(m => m && m.key === key);
    if (existingIdx >= 0) {
      mutations[existingIdx] = {
        ...mutations[existingIdx],
        payload,
        ts: Date.now()
      };
    } else {
      mutations.push({
        id: `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
        key,
        type,
        payload,
        ts: Date.now(),
        attempts: 0,
        nextTs: Date.now()
      });
    }
    writePendingMutations(mutations);
  }

  function prunePendingSaveForResponse(questionId, response) {
    if (!questionId || !response?.answer) return;
    const targetType = response.answerType || "append";
    const targetModel = response.model || "";
    const targetAnswer = String(response.answer || "").trim();
    const mutations = readPendingMutations();
    const next = mutations.filter((m) => {
      if (!m || m.type !== "saveAiAnswer") return true;
      const p = m.payload || {};
      const r = p.response || {};
      if (p.questionId !== questionId) return true;
      const t = p.answerType || r.answerType || "append";
      const model = r.model || "";
      const answer = String(r.answer || "").trim();
      return !(t === targetType && model === targetModel && answer === targetAnswer);
    });
    if (next.length !== mutations.length) {
      writePendingMutations(next);
      console.info("Pruned pending save mutations for deleted response", {
        questionId,
        removed: mutations.length - next.length
      });
    }
  }

  function withTimeout(promise, ms, label) {
    return Promise.race([
      promise,
      new Promise((_, reject) => setTimeout(() => reject(new Error(`${label} timeout`)), ms))
    ]);
  }

  function markCloudSyncTs() {
    try { localStorage.setItem(CLOUD_SYNC_TS_KEY, String(Date.now())); } catch {}
  }

  async function ensureAuthContext() {
    if (!isCloudReady()) return false;
    const session = await getActiveSession();
    if (session?.access_token && authUser?.id) return true;
    try {
      authUser = session?.user || null;
      if (!authUser && supabaseStore?.getUser) {
        authUser = await supabaseStore.getUser();
      }
      if (authUser) {
        await refreshAuthUser();
        return true;
      }
    } catch (e) {
      console.warn("ensureAuthContext failed", e);
    }
    return false;
  }

  function buildRestUrl(path, query = "") {
    const base = supabaseStore?.url || SUPABASE_URL_DIRECT;
    const q = query ? (query.startsWith("?") ? query : `?${query}`) : "";
    return `${base}/rest/v1/${path}${q}`;
  }

  async function restRequest(path, { method = "GET", query = "", body = null, prefer = "return=representation" } = {}) {
    const key = supabaseStore?.anonKey || SUPABASE_ANON_KEY_DIRECT;
    const session = await getActiveSession();
    const accessToken = session?.access_token || null;
    if (!accessToken) {
      throw new Error(`AUTH_SESSION_MISSING for ${method} ${path}`);
    }
    const headers = {
      apikey: key,
      Authorization: `Bearer ${accessToken}`
    };
    if (prefer) headers.Prefer = prefer;
    if (body !== null) headers["Content-Type"] = "application/json";
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), REST_TIMEOUT_MS);
    let res;
    try {
      res = await fetch(buildRestUrl(path, query), {
        method,
        headers,
        body: body !== null ? JSON.stringify(body) : undefined,
        cache: "no-store",
        signal: controller.signal
      });
    } catch (e) {
      if (e?.name === "AbortError") {
        throw new Error(`${method} ${path} timeout`);
      }
      throw e;
    } finally {
      clearTimeout(timer);
    }
    const raw = await res.text();
    let data = null;
    try { data = raw ? JSON.parse(raw) : null; } catch { data = raw; }
    if (!res.ok) {
      throw new Error(`${method} ${path} failed: ${res.status} ${typeof data === "string" ? data : JSON.stringify(data)}`);
    }
    return data;
  }

  function getLocalProgressRows() {
    const rows = [];
    const dedupe = new Map();
    for (let i = 0; i < localStorage.length; i += 1) {
      const key = localStorage.key(i) || "";
      if (!key.startsWith("studied_") && !key.startsWith("unclear_")) continue;
      const status = key.startsWith("studied_") ? "studied" : "unclear";
      let arr = [];
      try { arr = JSON.parse(localStorage.getItem(key) || "[]"); } catch {}
      if (!Array.isArray(arr)) continue;
      arr.forEach((questionId) => {
        if (!questionId) return;
        dedupe.set(String(questionId), status);
      });
    }
    dedupe.forEach((status, questionId) => {
      rows.push({
        user_id: authUser.id,
        question_id: questionId,
        status,
        updated_at: new Date().toISOString()
      });
    });
    return rows;
  }

  function aiSignature(questionId, answerType, model, content) {
    return `${questionId}::${answerType || "append"}::${model || ""}::${String(content || "").trim()}`;
  }

  function readLocalAiResponses(questionId) {
    if (!questionId) return [];
    try {
      const raw = localStorage.getItem(`${AI_RESPONSES_LOCAL_PREFIX}${questionId}`);
      const arr = JSON.parse(raw || "[]");
      return Array.isArray(arr) ? arr : [];
    } catch {
      return [];
    }
  }

  function writeLocalAiResponses(questionId, responses) {
    if (!questionId) return;
    try {
      const normalized = (Array.isArray(responses) ? responses : [])
        .filter(x => x && x.answer)
        .slice(-10)
        .map(x => ({
          answer: x.answer,
          model: x.model || "",
          seconds: x.seconds || 0,
          arrivedAt: x.arrivedAt || Date.now(),
          answerType: x.answerType || "append",
          cloudId: x.cloudId || null
        }));
      if (!normalized.length) {
        localStorage.removeItem(`${AI_RESPONSES_LOCAL_PREFIX}${questionId}`);
        return;
      }
      safeSetItemWithAiEviction(
        `${AI_RESPONSES_LOCAL_PREFIX}${questionId}`,
        JSON.stringify(normalized)
      );
    } catch (e) {
      console.warn("Failed to write local AI responses", e);
    }
  }

  function getLocalAiRows(existingSignatures) {
    const rows = [];
    for (let i = 0; i < localStorage.length; i += 1) {
      const key = localStorage.key(i) || "";
      if (!key.startsWith(AI_RESPONSES_LOCAL_PREFIX)) continue;
      const questionId = key.slice(AI_RESPONSES_LOCAL_PREFIX.length);
      if (!questionId) continue;
      let arr = [];
      try { arr = JSON.parse(localStorage.getItem(key) || "[]"); } catch {}
      if (!Array.isArray(arr)) continue;
      arr.forEach((entry) => {
        const content = String(entry?.answer || "").trim();
        if (!content) return;
        const answerType = entry?.answerType || "append";
        const model = entry?.model || null;
        const seconds = Number(entry?.seconds) || null;
        const signature = aiSignature(questionId, answerType, model, content);
        if (existingSignatures.has(signature)) return;
        existingSignatures.add(signature);
        rows.push({
          user_id: authUser.id,
          question_id: questionId,
          answer_type: answerType,
          model,
          seconds,
          content
        });
      });
    }

    // legacy fallback: single supplement entry
    for (let i = 0; i < localStorage.length; i += 1) {
      const key = localStorage.key(i) || "";
      if (!key.startsWith("ai_supplement_")) continue;
      const questionId = key.slice("ai_supplement_".length);
      if (!questionId) continue;
      const raw = localStorage.getItem(key);
      if (!raw) continue;
      let content = "";
      let model = null;
      let seconds = null;
      try {
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === "object") {
          content = String(parsed.text || "").trim();
          model = parsed.model || null;
          seconds = Number(parsed.seconds) || null;
        } else {
          content = String(parsed || "").trim();
        }
      } catch {
        content = String(raw || "").trim();
      }
      if (!content) continue;
      const signature = aiSignature(questionId, "append", model, content);
      if (existingSignatures.has(signature)) continue;
      existingSignatures.add(signature);
      rows.push({
        user_id: authUser.id,
        question_id: questionId,
        answer_type: "append",
        model,
        seconds,
        content
      });
    }
    return rows;
  }

  function applyCloudStateToUi() {
    runtimeQuestionsData.forEach((cat) => {
      const studiedKey = `studied_${cat.category}`;
      const unclearKey = `unclear_${cat.category}`;
      const studiedArr = JSON.parse(localStorage.getItem(studiedKey) || "[]");
      const unclearArr = JSON.parse(localStorage.getItem(unclearKey) || "[]");
      cat.items.forEach((item) => {
        const cloudStatus = cloudProgressByQuestion.get(item.id);
        if (cloudStatus === "studied") {
          if (!studiedArr.includes(item.id)) studiedArr.push(item.id);
          const idx = unclearArr.indexOf(item.id);
          if (idx >= 0) unclearArr.splice(idx, 1);
        } else if (cloudStatus === "unclear") {
          if (!unclearArr.includes(item.id)) unclearArr.push(item.id);
          const idx = studiedArr.indexOf(item.id);
          if (idx >= 0) studiedArr.splice(idx, 1);
        }
        const actionBtn = document.querySelector(`.study-btn[data-id="${item.id}"]`);
        const header = actionBtn?.closest(".t-item")?.querySelector(".t849__header");
        if (header) {
          header.classList.remove("studied", "unclear");
          if (cloudStatus === "studied") header.classList.add("studied");
          if (cloudStatus === "unclear") header.classList.add("unclear");
        }
      });
      safeSetItemWithAiEviction(studiedKey, JSON.stringify(studiedArr));
      safeSetItemWithAiEviction(unclearKey, JSON.stringify(unclearArr));
      updateProgress(cat.category, studiedArr.length, unclearArr.length, cat.items.length);
    });

    cloudAnswersByQuestion.forEach((rows, questionId) => {
      const state = aiItemState.get(questionId);
      if (!state || !Array.isArray(rows) || !rows.length) return;
      const existed = new Set(
        state.runtimeResponses.map((x) => aiSignature(questionId, x.answerType, x.model, x.answer))
      );
      rows.forEach((resp) => {
        const signature = aiSignature(questionId, resp.answerType, resp.model, resp.answer);
        if (existed.has(signature)) return;
        existed.add(signature);
        state.runtimeResponses.push(resp);
      });
      state.runtimeResponses.sort((a, b) => (a.arrivedAt || 0) - (b.arrivedAt || 0));
      if (state.runtimeResponses.length && typeof state.renderCurrentRuntimeResponse === "function") {
        state.renderCurrentRuntimeResponse();
      }
    });
  }

  async function syncLocalAndCloudState(options = {}) {
    const { force = false, source = "auto" } = options;
    if (!isCloudReady() || !authUser) return { ok: false };
    const now = Date.now();
    if (!force && cloudSyncPromise) return cloudSyncPromise;
    if (!force && (now - getCloudSyncLastTs()) < CLOUD_SYNC_TTL_MS) {
      return { ok: true, skipped: true };
    }
    cloudSyncPromise = (async () => {
      try {
        if (source === "manual") setAuthStatus("Синхронизация...");
        await withTimeout(Promise.all([loadCloudProgress(), loadCloudAnswers()]), CLOUD_OP_TIMEOUT_MS, "initial cloud load");

        const localProgressRows = getLocalProgressRows();
        if (localProgressRows.length) {
          if (supabaseStore.upsertQuestionProgressBulk) {
            const { error } = await withTimeout(
              supabaseStore.upsertQuestionProgressBulk(localProgressRows),
              CLOUD_OP_TIMEOUT_MS,
              "progress bulk upsert"
            );
            if (error) {
              console.warn("Bulk progress sync failed, fallback to row upsert", error);
              await Promise.all(localProgressRows.map((r) => saveProgressCloud(r.question_id, r.status)));
            }
          } else {
            await Promise.all(localProgressRows.map((r) => saveProgressCloud(r.question_id, r.status)));
          }
        }

        const cloudSignatures = new Set();
        cloudAnswersByQuestion.forEach((list, questionId) => {
          (list || []).forEach((resp) => {
            cloudSignatures.add(aiSignature(questionId, resp.answerType, resp.model, resp.answer));
          });
        });
        const localAiRows = getLocalAiRows(cloudSignatures);
        if (localAiRows.length) {
          if (supabaseStore.saveAiAnswersBulk) {
            const { error } = await withTimeout(
              supabaseStore.saveAiAnswersBulk(localAiRows),
              CLOUD_OP_TIMEOUT_MS,
              "ai answers bulk insert"
            );
            if (error) {
              console.warn("Bulk AI answers sync failed", error);
            }
          } else {
            await Promise.all(localAiRows.map((row) =>
              saveAiAnswerCloud(row.question_id, row.answer_type, {
                answer: row.content,
                model: row.model,
                seconds: row.seconds
              })
            ));
          }
        }

        if (localProgressRows.length || localAiRows.length || force) {
          await withTimeout(Promise.all([loadCloudProgress(), loadCloudAnswers()]), CLOUD_OP_TIMEOUT_MS, "final cloud reload");
        }
        applyCloudStateToUi();
        markCloudSyncTs();
        if (source === "manual") {
          setAuthStatus("Синхронизировано");
          setTimeout(() => {
            if ((authStatus?.textContent || "").includes("Синхронизировано")) setAuthStatus("");
          }, 1800);
        }
        await flushPendingMutations();
        return { ok: true };
      } catch (e) {
        if (source === "manual") {
          const msg = String(e?.message || "");
          if (msg.includes("timeout")) {
            setAuthStatus("Синхронизация: таймаут. Повторите.");
          } else {
            setAuthStatus("Синхронизация не удалась. Проверьте RLS.");
          }
        }
        console.warn("Cloud sync failed", e);
        return { ok: false, error: e };
      } finally {
        cloudSyncPromise = null;
      }
    })();
    return cloudSyncPromise;
  }

  function mapQuestionsPayload(sections, questions) {
    const grouped = new Map();
    (questions || []).forEach((q) => {
      const list = grouped.get(q.section_id) || [];
      list.push({
        id: q.id,
        title: q.title,
        answer: q.answer_html,
        moreLink: q.more_link || "",
        authorCheck: q.author_check || "",
        avatar: q.avatar || ""
      });
      grouped.set(q.section_id, list);
    });
    const mapped = (sections || [])
      .map((s) => ({
        category: s.title,
        items: grouped.get(s.id) || []
      }))
      .filter((s) => s.items.length);
    return mapped.length ? mapped : null;
  }

  async function loadQuestionsFromDbViaRest() {
    const base = supabaseStore?.url || SUPABASE_URL_DIRECT;
    const key = supabaseStore?.anonKey || SUPABASE_ANON_KEY_DIRECT;
    if (!base || !key) return null;
    const headers = {
      apikey: key,
      Authorization: `Bearer ${key}`
    };
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000);
    console.info("Loading questions from Supabase REST...");
    let sectionsRes;
    let questionsRes;
    try {
      [sectionsRes, questionsRes] = await Promise.all([
        fetch(`${base}/rest/v1/question_sections?select=id,title,sort_order&order=sort_order.asc`, {
          headers,
          mode: "cors",
          cache: "no-store",
          signal: controller.signal
        }),
        fetch(`${base}/rest/v1/questions?select=id,section_id,title,answer_html,more_link,author_check,avatar,sort_order&order=sort_order.asc`, {
          headers,
          mode: "cors",
          cache: "no-store",
          signal: controller.signal
        })
      ]);
    } finally {
      clearTimeout(timeoutId);
    }
    if (!sectionsRes.ok || !questionsRes.ok) {
      throw new Error(`REST load failed: sections=${sectionsRes.status}, questions=${questionsRes.status}`);
    }
    const [sections, questions] = await Promise.all([sectionsRes.json(), questionsRes.json()]);
    const mapped = mapQuestionsPayload(sections, questions);
    console.info(`Supabase REST loaded: sections=${Array.isArray(sections) ? sections.length : 0}, questions=${Array.isArray(questions) ? questions.length : 0}`);
    return mapped;
  }

  async function loadQuestionsFromDbViaSdk() {
    const [sectionsRes, questionsRes] = await Promise.all([
      supabaseStore.client
        .from("question_sections")
        .select("id,title,sort_order")
        .order("sort_order", { ascending: true }),
      supabaseStore.client
        .from("questions")
        .select("id,section_id,title,answer_html,more_link,author_check,avatar,sort_order")
        .order("sort_order", { ascending: true })
    ]);
    if (sectionsRes.error) throw sectionsRes.error;
    if (questionsRes.error) throw questionsRes.error;
    return mapQuestionsPayload(sectionsRes.data || [], questionsRes.data || []);
  }

  async function loadQuestionsFromDb() {
    try {
      if (isCloudReady()) {
        try {
          const sdkData = await Promise.race([
            loadQuestionsFromDbViaSdk(),
            new Promise((_, reject) => setTimeout(() => reject(new Error("SDK timeout")), 2500))
          ]);
          if (sdkData) return sdkData;
        } catch (sdkErr) {
          console.warn("Supabase SDK questions load failed, fallback to REST", sdkErr);
        }
      }
      return await loadQuestionsFromDbViaRest();
    } catch (e) {
      console.warn("Failed to load questions from Supabase, fallback to local data", e);
      return null;
    }
  }

  async function loadQuestionsFromDbWithTimeout() {
    return loadQuestionsFromDb();
  }

  async function saveProgressCloud(questionId, status, options = {}) {
    const { enqueueOnFail = true } = options;
    const hasAuth = await ensureAuthContext();
    if (!isCloudReady() || !hasAuth || !questionId) {
      console.warn("Skip cloud progress save: no auth/cloud", { questionId, hasCloud: isCloudReady(), hasAuth });
      if (enqueueOnFail) enqueueMutation("saveProgress", { questionId, status });
      return;
    }
    const payload = {
      user_id: authUser.id,
      question_id: questionId,
      status,
      updated_at: new Date().toISOString()
    };
    try {
      await withTimeout(
        restRequest("question_progress", {
          method: "POST",
          query: "on_conflict=user_id,question_id",
          body: payload,
          prefer: "resolution=merge-duplicates,return=representation"
        }),
        CLOUD_OP_TIMEOUT_MS,
        "save progress"
      );
      console.info("Cloud progress saved", { questionId, status });
    } catch (e) {
      console.warn("Failed to save question progress to Supabase", e);
      if (enqueueOnFail) enqueueMutation("saveProgress", { questionId, status });
    }
  }

  async function saveAiAnswerCloud(questionId, answerType, response, options = {}) {
    const { enqueueOnFail = true } = options;
    const hasAuth = await ensureAuthContext();
    if (!isCloudReady() || !hasAuth || !questionId || !response?.answer) {
      console.warn("Skip cloud AI save: no auth/cloud", { questionId, hasCloud: isCloudReady(), hasAuth });
      if (enqueueOnFail && questionId && response?.answer) {
        enqueueMutation("saveAiAnswer", { questionId, answerType, response });
      }
      return null;
    }
    const payload = {
      user_id: authUser.id,
      question_id: questionId,
      answer_type: answerType || response.answerType || "append",
      model: response.model || null,
      seconds: response.seconds || null,
      content: response.answer
    };
    try {
      const data = await withTimeout(
        restRequest("ai_answers", {
          method: "POST",
          body: payload,
          prefer: "return=representation"
        }),
        CLOUD_OP_TIMEOUT_MS,
        "save ai answer"
      );
      const row = Array.isArray(data) ? data[0] : data;
      console.info("Cloud AI answer saved", { questionId, answerType: payload.answer_type, model: payload.model });
      return row?.id || null;
    } catch (e) {
      console.warn("Failed to save AI answer to Supabase", e);
      if (enqueueOnFail) enqueueMutation("saveAiAnswer", { questionId, answerType, response });
      return null;
    }
  }

  async function deleteAiAnswerCloud(answerId, options = {}) {
    const { enqueueOnFail = true } = options;
    const hasAuth = await ensureAuthContext();
    if (!isCloudReady() || !hasAuth || !answerId) {
      console.warn("Skip cloud AI delete by id: no auth/cloud", { answerId, hasCloud: isCloudReady(), hasAuth });
      if (enqueueOnFail && answerId) enqueueMutation("deleteAiById", { answerId });
      return false;
    }
    try {
      const data = await withTimeout(
        restRequest("ai_answers", {
          method: "DELETE",
          query: `id=eq.${encodeURIComponent(answerId)}&user_id=eq.${encodeURIComponent(authUser.id)}`,
          prefer: "return=representation"
        }),
        CLOUD_OP_TIMEOUT_MS,
        "delete ai by id"
      );
      console.info("Cloud AI answer deleted by id", { answerId });
      return Array.isArray(data) ? data.length > 0 : true;
    } catch (e) {
      console.warn("Failed to delete AI answer from Supabase", e);
      if (enqueueOnFail) enqueueMutation("deleteAiById", { answerId });
      return false;
    }
  }

  async function deleteAiAnswerCloudByPayload(questionId, response, options = {}) {
    const { enqueueOnFail = true } = options;
    const hasAuth = await ensureAuthContext();
    if (!isCloudReady() || !hasAuth || !questionId || !response?.answer) {
      console.warn("Skip cloud AI delete by payload: no auth/cloud", { questionId, hasCloud: isCloudReady(), hasAuth });
      if (enqueueOnFail && questionId && response?.answer) enqueueMutation("deleteAiByPayload", { questionId, response });
      return false;
    }
    let query = `user_id=eq.${encodeURIComponent(authUser.id)}&question_id=eq.${encodeURIComponent(questionId)}&content=eq.${encodeURIComponent(response.answer)}&answer_type=eq.${encodeURIComponent(response.answerType || "append")}`;
    if (response.model) query += `&model=eq.${encodeURIComponent(response.model)}`;
    try {
      const data = await withTimeout(
        restRequest("ai_answers", {
          method: "DELETE",
          query,
          prefer: "return=representation"
        }),
        CLOUD_OP_TIMEOUT_MS,
        "delete ai by payload"
      );
      console.info("Cloud AI answer deleted by payload", { questionId });
      return Array.isArray(data) ? data.length > 0 : true;
    } catch (e) {
      console.warn("Failed to delete AI answer by payload from Supabase", e);
      if (enqueueOnFail) enqueueMutation("deleteAiByPayload", { questionId, response });
      return false;
    }
  }

  async function flushPendingMutations() {
    if (!isCloudReady() || !authUser) return;
    const queue = readPendingMutations();
    if (!queue.length) return;
    const now = Date.now();
    const failed = [];
    for (const m of queue) {
      if ((m?.nextTs || 0) > now) {
        failed.push(m);
        continue;
      }
      try {
        if (m.type === "saveProgress") {
          await saveProgressCloud(m.payload.questionId, m.payload.status, { enqueueOnFail: false });
        } else if (m.type === "saveAiAnswer") {
          const id = await saveAiAnswerCloud(m.payload.questionId, m.payload.answerType, m.payload.response, { enqueueOnFail: false });
          if (!id) throw new Error("saveAiAnswer retry failed");
        } else if (m.type === "deleteAiById") {
          const ok = await deleteAiAnswerCloud(m.payload.answerId, { enqueueOnFail: false });
          if (!ok) throw new Error("deleteAiById retry failed");
        } else if (m.type === "deleteAiByPayload") {
          const ok = await deleteAiAnswerCloudByPayload(m.payload.questionId, m.payload.response, { enqueueOnFail: false });
          if (!ok) throw new Error("deleteAiByPayload retry failed");
        }
      } catch {
        const attempts = Number(m?.attempts || 0) + 1;
        const backoffMs = Math.min(120000, 5000 * attempts);
        failed.push({
          ...m,
          attempts,
          nextTs: Date.now() + backoffMs
        });
      }
    }
    writePendingMutations(failed);
    if (!failed.length) {
      console.info("Pending mutations flushed");
    } else {
      console.warn("Pending mutations left", failed.length);
    }
  }

  async function ensureAuthForAiAction() {
    if (!isCloudReady()) {
      showAuthModal("Supabase не подключен. Перезагрузите страницу.");
      return false;
    }
    const hasAuth = await ensureAuthContext();
    if (hasAuth) return true;
    showAuthModal("");
    return false;
  }

  if (apiKeySave) {
    apiKeySave.addEventListener("click", () => {
      const v = apiKeyInput?.value?.trim();
      if (v) {
        safeSetItemWithAiEviction(OVERRIDE_API_KEY_STORAGE, v);
        hideApiKeyModal();
        if (pendingRetry) {
          const retry = pendingRetry;
          pendingRetry = null;
          retry();
        }
      }
    });
  }

  if (apiKeyClose) {
    apiKeyClose.addEventListener("click", () => {
      pendingRetry = null;
      hideApiKeyModal();
    });
  }

  if (authOpenBtn) {
    authOpenBtn.addEventListener("click", async () => {
      showAuthModal("");
      authModal?.classList.add("auth-checking");
      setAuthStatus("Проверяю сессию...");
      try {
        await refreshAuthUser();
      } finally {
        authModal?.classList.remove("auth-checking");
      }
      applyAuthModalMode();
      setAuthStatus("");
    });
  }

  if (authSendBtn) {
    authSendBtn.addEventListener("click", async () => {
      if (!isCloudReady()) {
        setAuthStatus("Supabase не подключен.");
        return;
      }
      const isAuthorizedView = !!authUser;
      if (isAuthorizedView) {
        try {
          const session = await getActiveSession();
          if (!session?.access_token) {
            authUser = null;
            authProfile = null;
            updateAuthButtonLabel();
            applyAuthModalMode();
            setAuthStatus("Сессия истекла. Войдите заново.");
            return;
          }
          const signOutFn = supabaseStore.signOut || (supabaseStore.client?.auth?.signOut
            ? () => supabaseStore.client.auth.signOut()
            : null);
          if (!signOutFn) {
            setAuthStatus("Выход недоступен. Обновите страницу.");
            return;
          }
          const { error } = await signOutFn();
          if (error) {
            setAuthStatus("Не удалось выйти. Попробуйте снова.");
            return;
          }
          authUser = null;
          authProfile = null;
          updateAuthButtonLabel();
          hideAuthModal();
        } catch (e) {
          console.warn("Sign out failed", e);
          setAuthStatus("Не удалось выйти. Попробуйте снова.");
        }
        return;
      }
      await refreshAuthUser();
      const track = (authTrackSelect?.value || "").trim();
      const grade = (authGradeSelect?.value || "").trim();
      if (!track || !grade) {
        setAuthStatus("Выберите направление и уровень.");
        return;
      }
      const email = (authEmailInput?.value || "").trim();
      if (!email) {
        setAuthStatus("Введите email.");
        return;
      }
      writePendingProfile({ email, track, grade, ts: Date.now() });
      setAuthStatus("Отправляю ссылку для входа...");
      const redirectTo = getCleanRedirectUrl();
      const { error } = await supabaseStore.signInWithOtp(email, redirectTo);
      if (error) {
        const errCode = String(error.code || "");
        const errMsg = String(error.message || "").toLowerCase();
        if (errCode === "over_email_send_rate_limit" || errMsg.includes("email rate limit exceeded")) {
          setAuthStatus("Лимит писем Supabase исчерпан. Подождите 60 сек и попробуйте снова.");
          authSendBtn.disabled = true;
          setTimeout(() => {
            authSendBtn.disabled = false;
          }, 60000);
          return;
        }
        setAuthStatus("Не удалось отправить ссылку. Проверьте email и повторите.");
        return;
      }
      setAuthStatus("Ссылка отправлена. Откройте письмо и вернитесь на страницу.");
    });
  }

  if (authEmailToggle) {
    authEmailToggle.addEventListener("click", () => {
      if (authUser) return;
      setEmailLoginExpanded(!authEmailLoginExpanded);
      applyAuthModalMode();
      positionAuthModal();
      if (authEmailLoginExpanded && authEmailInput) {
        requestAnimationFrame(() => authEmailInput.focus());
      }
    });
  }

  if (authGoogleBtn) {
    authGoogleBtn.addEventListener("click", async () => {
      if (!isCloudReady()) {
        setAuthStatus("Supabase не подключен.");
        return;
      }
      const track = (authTrackSelect?.value || "").trim();
      const grade = (authGradeSelect?.value || "").trim();
      if (!track || !grade) {
        setAuthStatus("Выберите направление и уровень.");
        return;
      }
      writePendingProfile({
        email: (authEmailInput?.value || "").trim() || null,
        track,
        grade,
        ts: Date.now()
      });
      setAuthStatus("Перенаправляю в Google...");
      const redirectTo = getCleanRedirectUrl();
      const signInOAuthFn = supabaseStore.signInWithOAuth || (supabaseStore.client?.auth?.signInWithOAuth
        ? (provider, rt) => supabaseStore.client.auth.signInWithOAuth({ provider, options: { redirectTo: rt } })
        : null);
      if (!signInOAuthFn) {
        setAuthStatus("Google вход недоступен. Обновите страницу.");
        return;
      }
      const { error } = await signInOAuthFn("google", redirectTo);
      if (error) {
        console.warn("Google OAuth sign-in failed", error);
        setAuthStatus("Не удалось открыть Google вход.");
      }
    });
  }

  if (authCloseBtn) {
    authCloseBtn.addEventListener("click", hideAuthModal);
  }

  if (authSyncBtn) {
    authSyncBtn.addEventListener("click", async () => {
      const session = await getActiveSession();
      if (!session?.access_token) {
        authUser = null;
        authProfile = null;
        updateAuthButtonLabel();
        applyAuthModalMode();
        setAuthStatus("Сессия истекла. Войдите заново.");
        return;
      }
      await refreshAuthUser();
      if (!authUser) {
        setAuthStatus("Сначала войдите");
        return;
      }
      authSyncBtn.disabled = true;
      try {
        // явный REST ping, чтобы в Network всегда был виден запрос синхронизации
        await restRequest("question_progress", {
          method: "GET",
          query: `select=question_id&user_id=eq.${encodeURIComponent(authUser.id)}&limit=1`
        });
        await syncLocalAndCloudState({ force: true, source: "manual" });
      } finally {
        authSyncBtn.disabled = false;
      }
    });
  }

  if (authModal) {
    authModal.addEventListener("click", (e) => {
      if (e.target === authModal) hideAuthModal();
    });
  }

  window.addEventListener("resize", () => {
    if (authModal?.classList.contains("show")) {
      applyAuthModalMode();
      positionAuthModal();
    }
  });
  window.addEventListener("scroll", () => {
    if (authModal?.classList.contains("show")) positionAuthModal();
  }, { passive: true });

  if (isCloudReady() && supabaseStore.client?.auth?.onAuthStateChange) {
    supabaseStore.client.auth.onAuthStateChange(async (_event, session) => {
      authUser = session?.user || null;
      if (authUser) {
        await refreshAuthUser();
        setAuthStatus("");
        await syncLocalAndCloudState({ force: true, source: "auth" });
        await flushPendingMutations();
      } else {
        authProfile = null;
        updateAuthButtonLabel();
      }
      applyAuthModalMode();
    });
  }

  initializeCloudState().catch((e) => {
    console.warn("Cloud state init skipped", e);
  });
  setInterval(() => {
    if (!authUser) return;
    flushPendingMutations().catch((e) => console.warn("Pending flush failed", e));
  }, 15000);
  const cachedQuestionsData = readQuestionsCache();
  if (Array.isArray(cachedQuestionsData) && cachedQuestionsData.length) {
    runtimeQuestionsData = cachedQuestionsData;
    window.questionsData = runtimeQuestionsData;
    console.info(`Questions source: local cache (${runtimeQuestionsData.length} sections)`);
  } else {
    const dbData = await loadQuestionsFromDbWithTimeout();
    if (Array.isArray(dbData) && dbData.length) {
      runtimeQuestionsData = dbData;
      window.questionsData = runtimeQuestionsData;
      writeQuestionsCache(dbData);
      console.info(`Questions source: Supabase (${runtimeQuestionsData.length} sections)`);
    } else {
      runtimeQuestionsData = [];
      window.questionsData = runtimeQuestionsData;
      console.error("Questions source: Supabase load failed or returned empty. Front fallback is disabled.");
    }
  }

  function renderModelsList(models) {
    if (!modelsListEl) return;
    modelsListEl.innerHTML = "";
    models.forEach(m => {
      const li = document.createElement("li");
      li.textContent = m;
      modelsListEl.appendChild(li);
    });
  }

  function getPreferredModel(models) {
    const savedModel = localStorage.getItem("selectedModel");
    if (savedModel && models.includes(savedModel)) return savedModel;
    if (models.includes(DEFAULT_MODEL)) return DEFAULT_MODEL;
    return models[0] || DEFAULT_MODEL;
  }

  function applyModelSelection(models) {
    const preferred = getPreferredModel(models);
    safeSetItemWithAiEviction("selectedModel", preferred);
  }

  function setCurrentModels(models) {
    currentModels = Array.isArray(models) && models.length ? models.slice(0, 5) : FAST_MODEL_HINTS.slice(0, 5);
  }

  function readModelTimings() {
    try {
      return JSON.parse(localStorage.getItem(MODEL_TIMINGS_KEY) || "{}");
    } catch {
      return {};
    }
  }

  function writeModelTimings(map) {
    safeSetItemWithAiEviction(MODEL_TIMINGS_KEY, JSON.stringify(map));
  }

  function recordModelTiming(model, ms) {
    const map = readModelTimings();
    const prev = map[model];
    if (!prev) {
      map[model] = { avg: ms, count: 1 };
    } else {
      const nextCount = prev.count + 1;
      const nextAvg = (prev.avg * prev.count + ms) / nextCount;
      map[model] = { avg: nextAvg, count: nextCount };
    }
    writeModelTimings(map);
  }

  function readModelFailures() {
    try {
      return JSON.parse(localStorage.getItem(MODEL_FAILURES_KEY) || "{}");
    } catch {
      return {};
    }
  }

  function writeModelFailures(map) {
    safeSetItemWithAiEviction(MODEL_FAILURES_KEY, JSON.stringify(map));
  }

  function recordModelFailure(model, reason) {
    const map = readModelFailures();
    const now = Date.now();
    const prev = map[model] || { count: 0, last: 0, reasons: {} };
    const next = {
      count: prev.count + 1,
      last: now,
      reasons: { ...prev.reasons, [reason]: (prev.reasons[reason] || 0) + 1 }
    };
    map[model] = next;
    writeModelFailures(map);
  }

  function isModelBlocked(model) {
    const map = readModelFailures();
    const info = map[model];
    if (!info) return false;
    const hours6 = 6 * 60 * 60 * 1000;
    const isRecent = (Date.now() - info.last) < hours6;
    return isRecent && info.count >= 2;
  }

  function getModelOrder(preferred) {
    const base = currentModels.length ? currentModels : FAST_MODEL_HINTS.slice(0, 5);
    const timings = readModelTimings();
    const filtered = base.filter(m => !isModelBlocked(m));
    const pool = filtered.length ? filtered : base;
    const sorted = pool.slice().sort((a, b) => {
      const ta = timings[a]?.avg ?? Number.POSITIVE_INFINITY;
      const tb = timings[b]?.avg ?? Number.POSITIVE_INFINITY;
      if (ta === tb) return 0;
      return ta - tb;
    });
    const ordered = [];
    if (preferred && base.includes(preferred)) ordered.push(preferred);
    sorted.forEach(m => {
      if (!ordered.includes(m)) ordered.push(m);
    });
    return ordered;
  }

  function showLoader(el) {
    if (!el) return;
    el.innerHTML = AI_LOADER_HTML;
    delete el.dataset.waitingModel;
    el.classList.add("show");
  }

  function updateLoaderText(el, text) {
    if (!el) return;
    const label = el.querySelector(".ai-loader-text");
    if (label) label.textContent = text;
  }

  function startLoaderPhases(el) {
    if (!el) return null;
    updateLoaderText(el, "Жду ответ");
    const timers = [
      setTimeout(() => updateLoaderText(el, "Еще чуть-чуть…"), 3000),
      setTimeout(() => updateLoaderText(el, "Обрабатываю ответ модели"), 6000),
      setTimeout(() => updateLoaderText(el, "Я обязательно верну ответ"), 9000),
      setTimeout(() => {
        const modelName = el.dataset.waitingModel;
        updateLoaderText(el, modelName ? `Жду ответ от ${modelName}` : "Жду ответ");
      }, 12000)
    ];
    return timers;
  }

  function stopLoaderPhases(timer) {
    if (!timer) return;
    if (Array.isArray(timer)) {
      timer.forEach(t => clearTimeout(t));
    } else {
      clearInterval(timer);
    }
  }

  async function fetchAnswerOnce(userQ, model, options = {}) {
    const { system = systemPrompt } = options;
    const startedAt = Date.now();
    const res = await fetch(`${IO_API_BASE}/chat/completions`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${getAuthKey()}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: "system", content: system },
          { role: "user",   content: userQ }
        ],
        temperature: 0.7,
        reasoning_content: false,
        max_completion_tokens: 1000,
        stream: false
      })
    });
    if (!res.ok) {
      let detail = "";
      try {
        const errJson = await res.json();
        detail = errJson?.detail || "";
      } catch {}
      if (detail && /invalid api key/i.test(detail)) {
        throw new Error("INVALID_API_KEY");
      }
      throw new Error(`AI request failed: ${res.status}`);
    }
    const json = await res.json();
    const msg = json.choices?.[0]?.message;
    const answer = msg?.content?.trim();
    if (!answer) {
      const hasReasoning = Array.isArray(msg?.reasoning_details) && msg.reasoning_details.length > 0;
      recordModelFailure(model, hasReasoning ? "reasoning_only" : "empty_content");
      throw new Error("Empty AI answer");
    }
    recordModelTiming(model, Date.now() - startedAt);
    return answer;
  }

  async function warmupModelOnce(model) {
    const startedAt = Date.now();
    const res = await fetch(`${IO_API_BASE}/chat/completions`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${getAuthKey()}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: "system", content: "Ответь очень кратко одним словом: OK." },
          { role: "user", content: "OK?" }
        ],
        temperature: 0,
        reasoning_content: false,
        max_completion_tokens: 32,
        stream: false
      })
    });
    if (!res.ok) {
      let detail = "";
      try {
        const errJson = await res.json();
        detail = errJson?.detail || "";
      } catch {}
      if (detail && /invalid api key/i.test(detail)) {
        throw new Error("INVALID_API_KEY");
      }
      recordModelFailure(model, `warmup_${res.status}`);
      throw new Error(`Warmup failed: ${res.status}`);
    }
    const json = await res.json();
    const msg = json.choices?.[0]?.message;
    const answer = msg?.content?.trim();
    if (!answer) {
      const hasReasoning = Array.isArray(msg?.reasoning_details) && msg.reasoning_details.length > 0;
      recordModelFailure(model, hasReasoning ? "warmup_reasoning_only" : "warmup_empty_content");
      throw new Error("Warmup empty");
    }
    recordModelTiming(model, Date.now() - startedAt);
    return answer;
  }

  function shouldWarmup() {
    const last = Number(localStorage.getItem(MODEL_WARMUP_KEY) || 0);
    const hours6 = 6 * 60 * 60 * 1000;
    return !last || (Date.now() - last) > hours6;
  }

  function markWarmup() {
    safeSetItemWithAiEviction(MODEL_WARMUP_KEY, String(Date.now()));
  }

  async function warmupModels(models) {
    const list = (models && models.length ? models : currentModels).slice(0, 5);
    await Promise.allSettled(list.map(m => warmupModelOnce(m)));
    markWarmup();
    // Обновляем порядок по скорости и сохраняем самую быструю
    const ordered = getModelOrder(getPreferredModel(list));
    setCurrentModels(ordered);
    applyModelSelection(ordered);
    renderModelsList(ordered);
  }

  function requestBatchWithTimeout(userQ, order, onAttempt, onAdditional, options = {}) {
    const ATTEMPT_DELAY_MS = 10000;
    return new Promise((resolve, reject) => {
      let completed = 0;
      let invalidCount = 0;
      let lastErr = null;
      let firstResolved = false;

      order.forEach((model, idx) => {
        setTimeout(async () => {
          // Если первый ответ уже получен, новые запросы к моделям не запускаем.
          if (firstResolved) {
            completed += 1;
            return;
          }
          try {
            if (typeof onAttempt === "function") onAttempt(model, idx + 1, order.length);
            const answer = await fetchAnswerOnce(userQ, model, options);
            const payload = { answer, model, arrivedAt: Date.now() };
            if (!firstResolved) {
              firstResolved = true;
              resolve(payload);
            } else if (typeof onAdditional === "function") {
              onAdditional(payload);
            }
          } catch (e) {
            lastErr = e;
            if (e && String(e.message).includes("INVALID_API_KEY")) invalidCount += 1;
            console.warn(`Model failed: ${model}`, e);
          } finally {
            completed += 1;
            if (completed === order.length && !firstResolved) {
              reject({
                error: lastErr || new Error("No AI answer"),
                invalidCount,
                total: order.length,
                tried: order.slice()
              });
            }
          }
        }, idx * ATTEMPT_DELAY_MS);
      });
    });
  }

  async function requestWithFallback(userQ, preferredModel, onAttempt, onAdditional, options = {}) {
    const order = getModelOrder(preferredModel);
    try {
      return await requestBatchWithTimeout(userQ, order, onAttempt, onAdditional, options);
    } catch (batchErr) {
      if (batchErr?.invalidCount === batchErr?.total) {
        showApiKeyModal();
        throw batchErr.error || new Error("INVALID_API_KEY");
      }
      if (modelListFromCache) {
        const refreshed = await loadModels({ force: true, exclude: batchErr?.tried || order });
        const retryOrder = getModelOrder(getPreferredModel(refreshed));
        try {
          return await requestBatchWithTimeout(userQ, retryOrder, onAttempt, onAdditional, options);
        } catch (retryErr) {
          if (retryErr?.invalidCount === retryErr?.total) {
            showApiKeyModal();
            throw retryErr.error || new Error("INVALID_API_KEY");
          }
          throw retryErr.error || new Error("No AI answer");
        }
      }
      throw batchErr.error || new Error("No AI answer");
    }
  }

  async function loadModels(options = {}) {
    const { force = false, exclude = [] } = options;
    const fallback = FAST_MODEL_HINTS.slice(0, 5).filter(m => !exclude.includes(m));
    if (!force) {
      const cached = readModelListCache();
      if (cached && cached.length) {
        const filtered = cached.filter(m => !exclude.includes(m)).slice(0, 5);
        const useList = filtered.length ? filtered : cached.slice(0, 5);
        setCurrentModels(useList);
        applyModelSelection(useList);
        renderModelsList(useList);
        modelListFromCache = true;
        return useList;
      }
    }
    try {
      const res = await fetch(`${IO_API_BASE}/models?page_size=100`, {
        headers: {
          "Authorization": `Bearer ${getAuthKey()}`
        }
      });
      if (!res.ok) throw new Error(`Models list failed: ${res.status}`);
      const json = await res.json();
      const apiModels = (json?.data || [])
        .filter(m => {
          const status = (m?.status || "").toLowerCase();
          if (status && status !== "active") return false;
          const enable = m?.metadata?.enable_api_chat_completions;
          if (enable === false) return false;
          return true;
        })
        .map(m => m?.name || m?.id)
        .filter(Boolean);
      const noReasoning = apiModels.filter(name => {
        const n = name.toLowerCase();
        return !(
          n.includes("thinking") ||
          n.includes("reasoning") ||
          n.includes("deepseek-r1") ||
          n.includes("r1") ||
          n.includes("o1") ||
          n.includes("o3") ||
          n.includes("vl") ||
          n.includes("vision")
        );
      });
      const hinted = FAST_MODEL_HINTS.filter(m => noReasoning.includes(m) && !exclude.includes(m));
      const pool = hinted.length ? hinted : (noReasoning.length ? noReasoning : apiModels);
      const finalModels = (pool.length ? pool : fallback).filter(m => !exclude.includes(m)).slice(0, 5);
      setCurrentModels(finalModels);
      applyModelSelection(finalModels);
      renderModelsList(finalModels);
      writeModelListCache(finalModels);
      modelListFromCache = false;
      return finalModels;
    } catch (e) {
      console.warn("Using fallback model list", e);
      setCurrentModels(fallback);
      applyModelSelection(fallback);
      renderModelsList(fallback);
      modelListFromCache = false;
      return fallback;
    }
  }


  // --- Typewriter effect для AI-ответа ---
  function typeWriter(el, text, startSpeed = 50, endSpeed = 0) {
    el.textContent = "";
    let i = 0, total = text.length;
    (function write() {
      if (i < total) {
        el.textContent += text.charAt(i++);
        const progress = total > 1 ? (i / (total - 1)) : 1;
        const delay = startSpeed + (endSpeed - startSpeed) * progress;
        setTimeout(write, Math.max(delay, 0));
      }
    })();
  }

  function showSupplementLoader(el) {
    if (!el) return;
    el.innerHTML = AI_LOADER_HTML;
    delete el.dataset.waitingModel;
    el.style.display = "block";
  }

  function formatSecondsRu(seconds) {
    const n = Math.abs(Number(seconds) || 0);
    const mod100 = n % 100;
    const mod10 = n % 10;
    if (mod100 >= 11 && mod100 <= 14) return `${n} секунд`;
    if (mod10 === 1) return `${n} секунду`;
    if (mod10 >= 2 && mod10 <= 4) return `${n} секунды`;
    return `${n} секунд`;
  }

  function normalizeCategoryKey(category) {
    const value = String(category || "")
      .replace(/\s+/g, " ")
      .trim()
      .toUpperCase();
    if (!value || value === "ВСЕ") return "ALL";
    if (value === "БД" || value === "БАЗЫ ДАННЫХ") return "БАЗЫ ДАННЫХ";
    if (value === "GIT" || value === "GIT + IDE" || value === "GIT + IDE + SELENIUM") return "GIT";
    if (value === "ТЕОРИЯ") return "ТЕОРИЯ ТЕСТИРОВАНИЯ + СОФТЫ";
    return value;
  }

  function renderAiSupplement(el, text, seconds, modelName, nav, statusText) {
    if (!el) return;
    el.innerHTML = "";
    const head = document.createElement("div");
    head.className = "ai-supplement-head";
    const title = document.createElement("div");
    title.className = "ai-supplement-title";
    if (seconds) {
      title.innerHTML = `Ответ ИИ <span class="ai-time">за ${formatSecondsRu(seconds)}</span>`;
    } else {
      title.textContent = "Ответ ИИ";
    }
    head.appendChild(title);
    if (statusText) {
      const inlineStatus = document.createElement("div");
      inlineStatus.className = "ai-supplement-inline-status";
      inlineStatus.innerHTML = `<span class="ai-inline-spinner"></span><span class="ai-time">${escapeHtml(statusText)}</span>`;
      head.appendChild(inlineStatus);
    }
    if (nav && nav.total > 1) {
      const controls = document.createElement("div");
      controls.className = "ai-supplement-nav";
      const prev = document.createElement("button");
      prev.type = "button";
      prev.className = "ai-nav-btn";
      prev.title = "Предыдущий ответ";
      prev.textContent = "‹";
      prev.addEventListener("click", nav.onPrev);
      const index = document.createElement("span");
      index.className = "ai-nav-index ai-time";
      index.textContent = `${nav.index + 1}/${nav.total}`;
      const next = document.createElement("button");
      next.type = "button";
      next.className = "ai-nav-btn";
      next.title = "Следующий ответ";
      next.textContent = "›";
      next.addEventListener("click", nav.onNext);
      controls.appendChild(prev);
      controls.appendChild(index);
      controls.appendChild(next);
      if (typeof nav.onDelete === "function") {
        const del = document.createElement("button");
        del.type = "button";
        del.className = "ai-nav-delete";
        del.title = "Удалить этот ответ";
        del.textContent = "🗑";
        del.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          nav.onDelete();
        });
        controls.appendChild(del);
      }
      head.appendChild(controls);
    } else if (nav && typeof nav.onDelete === "function") {
      const controls = document.createElement("div");
      controls.className = "ai-supplement-nav";
      const del = document.createElement("button");
      del.type = "button";
      del.className = "ai-nav-delete";
      del.title = "Удалить этот ответ";
      del.textContent = "🗑";
      del.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        nav.onDelete();
      });
      controls.appendChild(del);
      head.appendChild(controls);
    }
    const body = document.createElement("div");
    body.className = "ai-supplement-text ai-rich";
    try {
      body.innerHTML = formatAiText(String(text || ""));
    } catch (e) {
      console.warn("AI render failed, fallback to plain text", e);
      body.textContent = String(text || "");
    }
    el.appendChild(head);
    el.appendChild(body);
    if (modelName) {
      const meta = document.createElement("div");
      meta.className = "ai-supplement-meta";
      meta.innerHTML = `<span class="ai-time">ответила: ${escapeHtml(modelName)}</span>`;
      el.appendChild(meta);
    }
    el.style.display = "block";
  }

  let refineContext = null;

  const refineAction = document.createElement("button");
  refineAction.type = "button";
  refineAction.className = "ai-refine-action";
  refineAction.textContent = "Уточнить у ИИ";
  refineAction.style.display = "none";
  document.body.appendChild(refineAction);

  const refinePanel = document.createElement("div");
  refinePanel.className = "ai-refine-panel";
  refinePanel.style.display = "none";
  refinePanel.innerHTML = `
    <input type="text" class="ai-refine-input" placeholder="Что уточнить по выделенному тексту?" />
    <button type="button" class="ai-refine-send">Отправить</button>
    <button type="button" class="ai-refine-cancel">Закрыть</button>
  `;
  document.body.appendChild(refinePanel);

  const refineInput = refinePanel.querySelector(".ai-refine-input");
  const refineSend = refinePanel.querySelector(".ai-refine-send");
  const refineCancel = refinePanel.querySelector(".ai-refine-cancel");

  function hideRefineUi() {
    refineAction.style.display = "none";
    refinePanel.style.display = "none";
  }

  function buildRefinePrompt(context, userFollowup) {
    return [
      `Тема: ${context.category}`,
      `Основной вопрос: ${context.questionTitle}`,
      `Базовый ответ: ${context.baseAnswer}`,
      `Текущий ответ ИИ (если есть): ${context.currentAiAnswer || "нет"}`,
      `Выделенный фрагмент: ${context.selectedText}`,
      `Уточнение пользователя: ${userFollowup}`
    ].join("\n\n");
  }

  function showRefineAction(selection, context) {
    const range = selection.getRangeAt(0);
    const rect = range.getBoundingClientRect();
    if (!rect || (!rect.width && !rect.height)) return;
    refineContext = context;
    refineAction.style.display = "inline-flex";
    const left = Math.min(
      Math.max(8, rect.left + window.scrollX),
      window.scrollX + window.innerWidth - refineAction.offsetWidth - 8
    );
    refineAction.style.left = `${left}px`;
    refineAction.style.top = `${Math.max(8, rect.bottom + window.scrollY + 8)}px`;
  }

  function getSelectionContext(selection) {
    if (!selection || selection.rangeCount === 0) return null;
    const anchorNode = selection.anchorNode;
    const root = anchorNode && anchorNode.nodeType === 3 ? anchorNode.parentElement : anchorNode;
    if (!root) return null;
    const textRoot = root.closest(".t849__text");
    const aiTextRoot = root.closest(".ai-supplement-text");
    if (!textRoot && !aiTextRoot) return null;
    let itemId = "";
    if (textRoot) {
      itemId = textRoot.getAttribute("data-item-id") || "";
    } else if (aiTextRoot) {
      itemId = aiTextRoot.closest(".ai-supplement")?.getAttribute("data-id") || "";
    }
    if (!itemId) return null;
    const state = aiItemState.get(itemId);
    if (!state) return null;
    const selectedText = selection.toString().trim();
    if (!selectedText) return null;
    const current = state.runtimeResponses[state.runtimeIndex] || null;
    return {
      itemId,
      selectedText,
      category: state.category,
      questionTitle: state.questionTitle,
      baseAnswer: state.baseAnswer,
      currentAiAnswer: current ? current.answer : "",
      state
    };
  }

  document.addEventListener("selectionchange", () => {
    const selection = window.getSelection();
    if (!selection || selection.isCollapsed) {
      refineAction.style.display = "none";
      return;
    }
    const context = getSelectionContext(selection);
    if (!context) {
      refineAction.style.display = "none";
      return;
    }
    showRefineAction(selection, context);
  });

  document.addEventListener("click", (e) => {
    const isRefineElement =
      refineAction.contains(e.target) ||
      refinePanel.contains(e.target);
    if (isRefineElement) return;
    const selection = window.getSelection();
    const hasActiveSelection = !!(
      selection &&
      !selection.isCollapsed &&
      String(selection.toString() || "").trim()
    );
    if (hasActiveSelection) return;
    hideRefineUi();
  });

  refineAction.addEventListener("click", async () => {
    if (!refineContext) return;
    const canContinue = await ensureAuthForAiAction();
    if (!canContinue) return;
    refinePanel.style.display = "flex";
    const left = parseInt(refineAction.style.left, 10) || 8;
    refinePanel.style.left = `${left}px`;
    refinePanel.style.top = `${parseInt(refineAction.style.top, 10) + 36}px`;
    requestAnimationFrame(() => {
      const rect = refinePanel.getBoundingClientRect();
      if (rect.right > window.innerWidth - 8) {
        const correctedLeft = Math.max(8, window.scrollX + window.innerWidth - rect.width - 8);
        refinePanel.style.left = `${correctedLeft}px`;
      }
    });
    if (refineInput) {
      refineInput.value = "";
      refineInput.focus();
    }
  });

  async function runRefineRequest(context, userFollowup) {
    const itemState = context.state;
    if (!itemState || typeof itemState.pushRuntimeResponse !== "function") return false;
    const preferredModel = getPreferredModel(currentModels);
    const startedAt = Date.now();
    const prompt = buildRefinePrompt(context, userFollowup);
    const hasExistingResponses = Array.isArray(itemState.runtimeResponses) && itemState.runtimeResponses.length > 0;
    if (hasExistingResponses && typeof itemState.setInlineStatus === "function") {
      itemState.setInlineStatus("Уточняю у ИИ");
    } else {
      showSupplementLoader(itemState.aiSupplementEl);
    }
    const timer = hasExistingResponses ? null : startLoaderPhases(itemState.aiSupplementEl);
    try {
      const result = await requestWithFallback(
        prompt,
        preferredModel,
        (modelName) => {
          if (hasExistingResponses && typeof itemState.setInlineStatus === "function") {
            itemState.setInlineStatus("Уточняю у ИИ");
          } else {
            itemState.aiSupplementEl.dataset.waitingModel = modelName;
            const currentText = itemState.aiSupplementEl.querySelector(".ai-loader-text")?.textContent || "";
            if (currentText.startsWith("Жду ответ от")) {
              updateLoaderText(itemState.aiSupplementEl, `Жду ответ от ${modelName}`);
            }
          }
        },
        (extraResult) => {
          const extraSeconds = Math.max(1, Math.round((extraResult.arrivedAt - startedAt) / 1000));
          const response = {
            answer: extraResult.answer,
            model: extraResult.model,
            seconds: extraSeconds,
            arrivedAt: extraResult.arrivedAt,
            answerType: "refine"
          };
          itemState.pushRuntimeResponse(response, { focus: false });
          saveAiAnswerCloud(context.itemId, "refine", response).then((id) => {
            if (id) {
              response.cloudId = id;
              if (response.__deleteRequested) deleteAiAnswerCloud(id);
            }
          });
        },
        { system: refineSystemPrompt }
      );
      stopLoaderPhases(timer);
      if (hasExistingResponses && typeof itemState.setInlineStatus === "function") {
        itemState.setInlineStatus("");
      }
      const seconds = Math.max(1, Math.round((Date.now() - startedAt) / 1000));
      const response = {
        answer: result.answer,
        model: result.model,
        seconds,
        arrivedAt: result.arrivedAt || Date.now(),
        answerType: "refine"
      };
      itemState.pushRuntimeResponse(response, { focus: false });
      saveAiAnswerCloud(context.itemId, "refine", response).then((id) => {
        if (id) {
          response.cloudId = id;
          if (response.__deleteRequested) deleteAiAnswerCloud(id);
        }
      });
      return true;
    } catch (e) {
      stopLoaderPhases(timer);
      if (e && String(e.message).includes("INVALID_API_KEY")) {
        pendingRetry = () => runRefineRequest(context, userFollowup);
        if (hasExistingResponses && typeof itemState.setInlineStatus === "function") {
          itemState.setInlineStatus("Уточняю у ИИ");
        } else {
          updateLoaderText(itemState.aiSupplementEl, "Повторяю запрос после сохранения ключа");
        }
        return false;
      }
      if (hasExistingResponses && typeof itemState.setInlineStatus === "function") {
        itemState.setInlineStatus("");
      }
      renderAiSupplement(itemState.aiSupplementEl, "Не удалось получить ответ от моделей. Попробуйте позже.");
      return false;
    }
  }

  if (refineSend) {
    refineSend.addEventListener("click", async () => {
      const followup = (refineInput?.value || "").trim();
      if (!refineContext || !followup) return;
      const canContinue = await ensureAuthForAiAction();
      if (!canContinue) return;
      const ctx = refineContext;
      hideRefineUi();
      await runRefineRequest(ctx, followup);
    });
  }

  if (refineInput) {
    refineInput.addEventListener("keydown", async (e) => {
      if (e.key !== "Enter") return;
      e.preventDefault();
      const followup = (refineInput.value || "").trim();
      if (!refineContext || !followup) return;
      const canContinue = await ensureAuthForAiAction();
      if (!canContinue) return;
      const ctx = refineContext;
      hideRefineUi();
      await runRefineRequest(ctx, followup);
    });
  }

  if (refineCancel) {
    refineCancel.addEventListener("click", hideRefineUi);
  }

  // --- Render accordion sections & items ---
  const container = document.getElementById("accordion-container");
  const tpl       = document.getElementById("accordion-item-template");

  function escapeHtml(str) {
    return str
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function detectLanguage(code) {
    const text = code.toUpperCase();
    if (/(SELECT|INSERT|UPDATE|DELETE|FROM|WHERE|JOIN|GROUP BY|ORDER BY|VALUES|CREATE|ALTER|DROP)\b/.test(text)) {
      return 'sql';
    }
    if (/(SYSTEM\.OUT\.PRINT|PUBLIC\s+CLASS|STATIC\s+VOID|STRING\s+|INT\s+)/.test(code)) {
      return 'java';
    }
    if (/(CONSOLE\.LOG|=>|\bLET\b|\bCONST\b|\bVAR\b|\bFUNCTION\b|\bASYNC\b|\bAWAIT\b)/i.test(code)) {
      return 'javascript';
    }
    if (/(DEF\s+|PRINT\(|\bNONE\b|\bTRUE\b|\bFALSE\b)/i.test(code)) {
      return 'python';
    }
    return '';
  }

  function highlightCode(code, lang) {
    let html = escapeHtml(code);

    // Comments
    if (lang === 'sql') {
      html = html.replace(/(--.*)$/gm, '<span class="tok-comment">$1</span>');
    } else {
      html = html.replace(/(\/\/.*)$/gm, '<span class="tok-comment">$1</span>');
      html = html.replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="tok-comment">$1</span>');
    }

    // Strings
    html = html.replace(/("([^"\\]|\\.)*")/g, '<span class="tok-string">$1</span>');
    html = html.replace(/('([^'\\]|\\.)*')/g, '<span class="tok-string">$1</span>');

    // Numbers
    html = html.replace(/\b(\d+(\.\d+)?)\b/g, '<span class="tok-number">$1</span>');

    // Keywords
    let keywords = [];
    if (lang === 'sql') {
      keywords = [
        'SELECT','FROM','WHERE','JOIN','LEFT','RIGHT','INNER','OUTER','GROUP','BY','ORDER','INSERT','UPDATE','DELETE',
        'CREATE','ALTER','DROP','DISTINCT','LIMIT','VALUES','INTO','AS','ON','AND','OR','NOT','NULL','IS','IN',
        'BETWEEN','LIKE','COUNT','AVG','MIN','MAX','SUM'
      ];
      const re = new RegExp(`\\b(${keywords.join('|')})\\b`, 'gi');
      html = html.replace(re, '<span class="tok-keyword">$1</span>');
    } else if (lang === 'java' || lang === 'javascript' || lang === 'python') {
      keywords = [
        'public','class','static','void','int','string','new','return','if','else','switch','case','break','default',
        'for','while','try','catch','throw','const','let','var','function','async','await','extends','import','from'
      ];
      const re = new RegExp(`\\b(${keywords.join('|')})\\b`, 'g');
      html = html.replace(re, '<span class="tok-keyword">$1</span>');
    }

    return html;
  }

  function enhanceAnswerBlock(textEl) {
    const codeNodes = Array.from(textEl.querySelectorAll('code'));
    codeNodes.forEach(codeEl => {
      const rawHtml = codeEl.innerHTML || '';
      const text = codeEl.textContent || '';
      const hasBreaks = /<br\s*\/?>/i.test(rawHtml) || text.includes('\n');
      const lang = detectLanguage(text);
      const looksLikeSqlStatement = lang === 'sql' && /\\b(SELECT|INSERT|UPDATE|DELETE|WITH)\\b/i.test(text);

      if (hasBreaks || looksLikeSqlStatement) {
        const pre = document.createElement('pre');
        pre.className = 'code-block';
        const code = document.createElement('code');
        if (lang) code.className = `language-${lang}`;
        const normalized = rawHtml
          .replace(/<br\s*\/?>/gi, '\n')
          .replace(/&nbsp;/g, ' ')
          .replace(/<[^>]*>/g, '');
        code.innerHTML = highlightCode(normalized, lang);
        pre.appendChild(code);
        codeEl.replaceWith(pre);
      } else {
        codeEl.classList.add('code-inline');
        codeEl.textContent = text;
      }
    });
  }

  function formatAiText(text) {
    if (!text) return "";
    const src = String(text);
    const parts = [];
    const re = /```(\w+)?\n([\s\S]*?)```/g;
    let last = 0;
    let m;
    while ((m = re.exec(src)) !== null) {
      if (m.index > last) {
        parts.push({ type: "text", value: src.slice(last, m.index) });
      }
      parts.push({ type: "code", lang: (m[1] || "").toLowerCase(), value: m[2] });
      last = m.index + m[0].length;
    }
    if (last < src.length) parts.push({ type: "text", value: src.slice(last) });

    function renderTextBlock(block) {
      let t = escapeHtml(block);
      // Normalize inline numbered lists like "1) ..." into new lines
      t = t.replace(/(\s)(\d{1,2})\)\s+/g, "\n$2. ");
      t = t.replace(/^###\s+(.*)$/gm, "<h4>$1</h4>");
      t = t.replace(/^##\s+(.*)$/gm, "<h3>$1</h3>");
      t = t.replace(/^#\s+(.*)$/gm, "<h2>$1</h2>");
      t = t.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
      t = t.replace(/\*(.+?)\*/g, "<em>$1</em>");
      t = t.replace(/`([^`]+)`/g, "<code>$1</code>");

      // Markdown-like tables
      const lines = t.split(/\r?\n/);
      const outLines = [];
      let i = 0;
      while (i < lines.length) {
        const line = lines[i];
        const isTableLine = /\|/.test(line);
        const next = lines[i + 1] || "";
        const isSeparator = /^\s*\|?\s*[-:]{3,}\s*(\|\s*[-:]{3,}\s*)+\|?\s*$/.test(next);
        if (isTableLine && isSeparator) {
          const headerCells = line.split("|").map(s => s.trim()).filter(s => s.length);
          const rows = [];
          i += 2;
          while (i < lines.length && /\|/.test(lines[i])) {
            const rowCells = lines[i].split("|").map(s => s.trim()).filter(s => s.length);
            if (rowCells.length) rows.push(rowCells);
            i++;
          }
          let tableHtml = '<div class="ai-table-wrap"><table class="ai-table"><thead><tr>';
          headerCells.forEach(c => { tableHtml += `<th>${c}</th>`; });
          tableHtml += '</tr></thead><tbody>';
          rows.forEach(r => {
            tableHtml += '<tr>';
            headerCells.forEach((_, idx) => {
              tableHtml += `<td>${r[idx] || ""}</td>`;
            });
            tableHtml += '</tr>';
          });
          tableHtml += '</tbody></table></div>';
          outLines.push(tableHtml);
          continue;
        }
        outLines.push(line);
        i++;
      }

      const lines2 = outLines;
      let out = "";
      let inUl = false;
      let inOl = false;
      lines2.forEach(line => {
        const ulMatch = line.match(/^\s*[-*]\s+(.*)$/);
        const olMatch = line.match(/^\s*\d+\.\s+(.*)$/);
        if (ulMatch) {
          if (inOl) { out += "</ol>"; inOl = false; }
          if (!inUl) { out += "<ul>"; inUl = true; }
          out += `<li>${ulMatch[1]}</li>`;
          return;
        }
        if (olMatch) {
          if (inUl) { out += "</ul>"; inUl = false; }
          if (!inOl) { out += "<ol>"; inOl = true; }
          out += `<li>${olMatch[1]}</li>`;
          return;
        }
        if (line.includes("ai-table")) {
          if (inUl) { out += "</ul>"; inUl = false; }
          if (inOl) { out += "</ol>"; inOl = false; }
          out += line;
          return;
        }
        if (inUl) { out += "</ul>"; inUl = false; }
        if (inOl) { out += "</ol>"; inOl = false; }
        out += line === "" ? "<br>" : `${line}<br>`;
      });
      if (inUl) out += "</ul>";
      if (inOl) out += "</ol>";

      out = out.replace(/<br>\s*<br>/g, "</p><p>");
      if (!out.startsWith("<")) out = `<p>${out}</p>`;
      if (!out.startsWith("<p>")) out = `<p>${out}</p>`;
      return out;
    }

    return parts.map(p => {
      if (p.type === "code") {
        const code = escapeHtml(p.value);
        return `<pre class="code-block"><code>${code}</code></pre>`;
      }
      return renderTextBlock(p.value);
    }).join("");
  }

  if (!Array.isArray(runtimeQuestionsData) || !runtimeQuestionsData.length) {
    if (container) {
      container.innerHTML = `
        <section class="article">
          <h3>Не удалось загрузить вопросы из БД</h3>
          <p>Проверьте запросы к Supabase в Network и ошибки в Console.</p>
        </section>
      `;
    }
  }

  runtimeQuestionsData.forEach(cat => {
    // 1. Создаем <section>
    const section = document.createElement("section");
    section.className = "article";
    section.dataset.categoryKey = normalizeCategoryKey(cat.category);

    // 2. Картинка и заголовок
    let imgSrc = "img/answer/default-category.png";
    switch (cat.category) {
      case "ТЕОРИЯ ТЕСТИРОВАНИЯ + СОФТЫ": imgSrc = "img/answer/theory.jpeg"; break;
      case "WEB":                         imgSrc = "img/answer/client-server-arch.jpeg"; break;
      case "API":                         imgSrc = "img/answer/restapi.jpeg"; break;
      case "БАЗЫ ДАННЫХ":                 imgSrc = "img/answer/mysql.jpeg"; break;
      case "GIT + IDE + SELENIUM":        imgSrc = "img/answer/git.jpeg"; break;
      case "DEVOPS":                      imgSrc = "img/answer/docker.jpeg"; break;
      case "Вопросы к руководителю | команде | HR": imgSrc = "img/answer/hr.jpeg"; break;
      case "AQA Java":                    imgSrc = "img/answer/AQAjava.jpeg"; break;
      case "AQA Python":                  imgSrc = "img/answer/AQApython.jpeg"; break;
      case "AQA JS":                      imgSrc = "img/answer/AQAjs.jpeg"; break;
    }

    section.innerHTML = `
      <div class="answer-image">
        <img src="${imgSrc}" alt="Иконка для ${cat.category}" class="category-icon" />
        <h3 class="category-title">${cat.category}</h3>
      </div>
    `;

    // 3. Прогресс-бар
    const total = cat.items.length;
    section.insertAdjacentHTML('beforeend', `
      <div class="progress-container">
        <div class="progress-bar-unclear" data-category="${cat.category}"></div>
        <div class="progress-bar"        data-category="${cat.category}"></div>
        <span class="progress-text"      data-category="${cat.category}">0%</span>
      </div>
    `);
    container.appendChild(section);

    // Восстанавливаем состояния из localStorage
    const studiedArr = JSON.parse(
      localStorage.getItem(`studied_${cat.category}`)
    ) || [];
    const unclearArr = JSON.parse(
      localStorage.getItem(`unclear_${cat.category}`)
    ) || [];
    cat.items.forEach(item => {
      const cloudStatus = cloudProgressByQuestion.get(item.id);
      if (cloudStatus === "studied") {
        if (!studiedArr.includes(item.id)) studiedArr.push(item.id);
        const idx = unclearArr.indexOf(item.id);
        if (idx >= 0) unclearArr.splice(idx, 1);
      } else if (cloudStatus === "unclear") {
        if (!unclearArr.includes(item.id)) unclearArr.push(item.id);
        const idx = studiedArr.indexOf(item.id);
        if (idx >= 0) studiedArr.splice(idx, 1);
      }
    });
    safeSetItemWithAiEviction(`studied_${cat.category}`, JSON.stringify(studiedArr));
    safeSetItemWithAiEviction(`unclear_${cat.category}`, JSON.stringify(unclearArr));
    updateProgress(cat.category, studiedArr.length, unclearArr.length, total);

    // 4. Render вопросов
    cat.items.forEach(item => {
      const openKey = "open_items";
      const openSet = new Set(JSON.parse(localStorage.getItem(openKey) || "[]"));
      const clone  = tpl.content.cloneNode(true);
      const header = clone.querySelector('.t849__header');
      const btn    = clone.querySelector('.t849__trigger-button');
      const title  = clone.querySelector('.t849__title');
      const content= clone.querySelector('.t849__content');
      const textEl = clone.querySelector('.t849__text');

      btn.setAttribute('aria-controls', item.id);
      title.textContent = item.title;
      content.id = item.id;

      // Собираем ссылки «Читать» и «Ревью от автора», если они есть
      // Собираем кнопки
      let readLinks = [];
      let authorLinks = [];
      if (item.moreLink) {
        readLinks.push(
          `<a href="${item.moreLink}" target="_blank" rel="noopener noreferrer" class="answer-link read-link">Читать</a>`
        );
      }
      if (item.authorCheck) {
        authorLinks.push(`
          <a
            href="${item.authorCheck}"
            target="_blank"
            rel="noopener noreferrer"
            class="answer-link author-link"
          >
            Блог ревьюера
            <img src="${item.avatar}" alt="Аватар ревьюера">
          </a>
        `);
      }

      let authorLinksBlock = '';
      if (authorLinks.length) {
        authorLinksBlock = `<br><br><div class="answer-links">${authorLinks.join('')}</div>`;
      }

      // вставляем в ответ
      textEl.innerHTML = item.answer + authorLinksBlock;
      textEl.setAttribute("data-item-id", item.id);
      enhanceAnswerBlock(textEl);
      const baseAnswerHolder = document.createElement("div");
      baseAnswerHolder.innerHTML = item.answer;
      const baseAnswerPlain = (baseAnswerHolder.textContent || "").trim();

      textEl.insertAdjacentHTML('beforeend', `
        <div class="answer-actions" style="margin-top:1rem;">
          <div class="answer-actions-left">
            <button type="button" class="answer-link study-btn"
                    data-category="${cat.category}" data-id="${item.id}"
                    title="Понимаю материал">
              &#10003;
            </button>
            <button type="button" class="unclear-btn"
                    data-category="${cat.category}" data-id="${item.id}"
                    title="Не до конца разбираюсь">
              ?
            </button>
          </div>
          <div class="answer-actions-right">
            ${readLinks.length ? `<div class="answer-links inline-links">${readLinks.join('')}</div>` : ""}
            <button type="button" class="ai-append-btn" data-id="${item.id}">Дополнить ответ от ИИ</button>
          </div>
        </div>
        <div class="ai-append-wrap" data-id="${item.id}">
          <div class="ai-supplement" data-id="${item.id}" style="display:none;"></div>
        </div>
      `);

      // Подкрашиваем «+» при рендере
      if (studiedArr.includes(item.id)) header.classList.add('studied');
      else if (unclearArr.includes(item.id)) header.classList.add('unclear');

      // Обработчик «✓»
      clone.querySelector('.study-btn').addEventListener('click', e => {
        const c = e.target.dataset.category;
        const id = e.target.dataset.id;
        const studiedKey = 'studied_' + c;
        const unclearKey = 'unclear_' + c;
        const sArr = JSON.parse(localStorage.getItem(studiedKey)) || [];
        let   uArr = JSON.parse(localStorage.getItem(unclearKey)) || [];
        if (!sArr.includes(id)) {
          sArr.push(id);
          uArr = uArr.filter(x => x !== id);
          safeSetItemWithAiEviction(studiedKey, JSON.stringify(sArr));
          safeSetItemWithAiEviction(unclearKey, JSON.stringify(uArr));
          header.classList.remove('unclear');
          header.classList.add('studied');
          updateProgress(c, sArr.length, uArr.length, total);
          saveProgressCloud(id, "studied");
        }
      });

      // Обработчик «?»
      clone.querySelector('.unclear-btn').addEventListener('click', e => {
        const c = e.target.dataset.category;
        const id = e.target.dataset.id;
        let   sArr = JSON.parse(localStorage.getItem('studied_' + c)) || [];
        const uKey = 'unclear_' + c;
        const uArr = JSON.parse(localStorage.getItem(uKey)) || [];
        if (!uArr.includes(id)) {
          uArr.push(id);
          sArr = sArr.filter(x => x !== id);
          safeSetItemWithAiEviction(uKey, JSON.stringify(uArr));
          safeSetItemWithAiEviction('studied_' + c, JSON.stringify(sArr));
          header.classList.remove('studied');
          header.classList.add('unclear');
          updateProgress(c, sArr.length, uArr.length, total);
          saveProgressCloud(id, "unclear");
        }
      });

      // Toggle accordion
      btn.addEventListener("click", () => {
        const expanded = btn.getAttribute("aria-expanded") === "true";
        btn.setAttribute("aria-expanded", !expanded);
        content.style.display = expanded ? "none" : "block";
        header.classList.toggle("t849__opened", !expanded);
        if (!expanded) openSet.add(item.id);
        else openSet.delete(item.id);
        safeSetItemWithAiEviction(openKey, JSON.stringify(Array.from(openSet)));
      });
      const supplementKey = `ai_supplement_${item.id}`;
      const aiAppendBtn = clone.querySelector(`.ai-append-btn[data-id="${item.id}"]`);
      const aiSupplementEl = clone.querySelector(`.ai-supplement[data-id="${item.id}"]`);
      const state = {
        id: item.id,
        category: cat.category,
        questionTitle: item.title,
        baseAnswer: baseAnswerPlain,
        aiSupplementEl,
        runtimeResponses: [],
        runtimeIndex: 0,
        inlineStatus: "",
        renderCurrentRuntimeResponse: null,
        pushRuntimeResponse: null,
        setInlineStatus: null
      };
      aiItemState.set(item.id, state);
      const cloudResponses = cloudAnswersByQuestion.get(item.id) || [];
      if (cloudResponses.length && aiSupplementEl) {
        cloudResponses.forEach(resp => state.runtimeResponses.push(resp));
        writeLocalAiResponses(item.id, state.runtimeResponses);
        const latest = cloudResponses[cloudResponses.length - 1];
        renderAiSupplement(aiSupplementEl, latest.answer, latest.seconds, latest.model);
      } else {
        const localResponses = readLocalAiResponses(item.id);
        if (localResponses.length && aiSupplementEl) {
          localResponses.forEach(resp => state.runtimeResponses.push(resp));
          const latest = localResponses[localResponses.length - 1];
          renderAiSupplement(aiSupplementEl, latest.answer, latest.seconds, latest.model);
        } else {
          const savedSupplement = localStorage.getItem(supplementKey);
          if (savedSupplement && aiSupplementEl) {
            try {
              const parsed = JSON.parse(savedSupplement);
              if (parsed && parsed.text) {
                state.runtimeResponses.push({
                  answer: parsed.text,
                  model: parsed.model,
                  seconds: parsed.seconds,
                  arrivedAt: 0,
                  answerType: "append"
                });
                writeLocalAiResponses(item.id, state.runtimeResponses);
                renderAiSupplement(aiSupplementEl, parsed.text, parsed.seconds, parsed.model);
              } else {
                renderAiSupplement(aiSupplementEl, savedSupplement);
              }
            } catch {
              renderAiSupplement(aiSupplementEl, savedSupplement);
            }
          }
        }
      }
      if (openSet.has(item.id)) {
        btn.setAttribute("aria-expanded", "true");
        content.style.display = "block";
        header.classList.add("t849__opened");
      }
      if (aiAppendBtn && aiSupplementEl) {
        const runtimeResponses = state.runtimeResponses;
        let runtimeIndex = state.runtimeIndex;
        let inlineStatus = state.inlineStatus || "";

        const syncLocalSupplementCache = () => {
          writeLocalAiResponses(item.id, runtimeResponses);
          if (cloudAnswersByQuestion.get(item.id)?.length || (isCloudReady() && authUser)) return;
          if (!runtimeResponses.length) {
            try {
              localStorage.removeItem(supplementKey);
            } catch {}
            return;
          }
          const current = runtimeResponses[runtimeIndex] || runtimeResponses[runtimeResponses.length - 1];
          try {
            saveAiSupplementWithLimit(
              supplementKey,
              { text: current.answer, seconds: current.seconds, model: current.model }
            );
          } catch (storageError) {
            console.warn("Failed to sync AI supplement cache", storageError);
          }
        };

        const removeRuntimeResponse = async () => {
          try {
            if (!runtimeResponses.length) return;
            if (!Number.isInteger(runtimeIndex) || runtimeIndex < 0 || runtimeIndex >= runtimeResponses.length) {
              runtimeIndex = runtimeResponses.length - 1;
            }
            const removing = runtimeResponses[runtimeIndex];
            if (!removing || typeof removing !== "object") return;
            removing.__deleteRequested = true;
            prunePendingSaveForResponse(item.id, removing);
            runtimeResponses.splice(runtimeIndex, 1);
            if (runtimeIndex >= runtimeResponses.length) {
              runtimeIndex = Math.max(0, runtimeResponses.length - 1);
            }
            if (runtimeResponses.length) {
              renderCurrentRuntimeResponse();
            } else {
              aiSupplementEl.style.display = "none";
              aiSupplementEl.innerHTML = "";
              try { localStorage.removeItem(supplementKey); } catch {}
              writeLocalAiResponses(item.id, []);
            }
            syncLocalSupplementCache();
            let deleted = false;
            if (removing?.cloudId) {
              console.info("Try cloud delete by id", { questionId: item.id, cloudId: removing.cloudId });
              deleted = await deleteAiAnswerCloud(removing.cloudId);
            }
            if (!deleted) {
              console.info("Try cloud delete by payload", { questionId: item.id });
              deleted = await deleteAiAnswerCloudByPayload(item.id, removing);
            }
            if (!deleted) {
              console.warn("AI response delete was not confirmed in cloud", { questionId: item.id, cloudId: removing?.cloudId || null });
              enqueueMutation("deleteAiByPayload", { questionId: item.id, response: removing });
            }
          } catch (e) {
            console.warn("Failed to remove runtime response", e);
          }
        };

        const renderCurrentRuntimeResponse = () => {
          if (!runtimeResponses.length) return;
          const current = runtimeResponses[runtimeIndex];
          state.runtimeIndex = runtimeIndex;
          renderAiSupplement(
            aiSupplementEl,
            current.answer,
            current.seconds,
            current.model,
            runtimeResponses.length > 1
                ? {
                    index: runtimeIndex,
                    total: runtimeResponses.length,
                    onPrev: () => {
                      runtimeIndex = (runtimeIndex - 1 + runtimeResponses.length) % runtimeResponses.length;
                      renderCurrentRuntimeResponse();
                    },
                    onNext: () => {
                      runtimeIndex = (runtimeIndex + 1) % runtimeResponses.length;
                      renderCurrentRuntimeResponse();
                    },
                    onDelete: removeRuntimeResponse
                  }
              : { onDelete: removeRuntimeResponse },
            inlineStatus
          );
        };
        state.renderCurrentRuntimeResponse = renderCurrentRuntimeResponse;
        state.setInlineStatus = (text) => {
          inlineStatus = text || "";
          if (runtimeResponses.length) renderCurrentRuntimeResponse();
        };

        const pushRuntimeResponse = (resp, options = {}) => {
          const { focus = false } = options;
          runtimeResponses.push(resp);
          runtimeResponses.sort((a, b) => a.arrivedAt - b.arrivedAt);
          if (runtimeResponses.length === 1) {
            runtimeIndex = 0;
          } else if (focus) {
            runtimeIndex = Math.max(
              0,
              runtimeResponses.findIndex(
                x => x.arrivedAt === resp.arrivedAt && x.answer === resp.answer && x.model === resp.model
              )
            );
          }
          renderCurrentRuntimeResponse();
          syncLocalSupplementCache();
        };
        state.pushRuntimeResponse = pushRuntimeResponse;

        aiAppendBtn.addEventListener("click", async () => {
          const canContinue = await ensureAuthForAiAction();
          if (!canContinue) return;
          const preferredModel = getPreferredModel(currentModels);
          aiAppendBtn.disabled = true;
          showSupplementLoader(aiSupplementEl);
          const supplementTimer = startLoaderPhases(aiSupplementEl);
          const executeRequest = async () => {
            const startedAt = Date.now();
            const promptWithCategory = `Тема: ${cat.category}. Вопрос: ${item.title}`;
            const result = await requestWithFallback(
              promptWithCategory,
              preferredModel,
              (modelName) => {
                aiSupplementEl.dataset.waitingModel = modelName;
                const currentText = aiSupplementEl.querySelector(".ai-loader-text")?.textContent || "";
                if (currentText.startsWith("Жду ответ от")) {
                  updateLoaderText(aiSupplementEl, `Жду ответ от ${modelName}`);
                }
              },
              (extraResult) => {
                const extraSeconds = Math.max(1, Math.round((extraResult.arrivedAt - startedAt) / 1000));
                const response = {
                  answer: extraResult.answer,
                  model: extraResult.model,
                  seconds: extraSeconds,
                  arrivedAt: extraResult.arrivedAt,
                  answerType: "append"
                };
                pushRuntimeResponse(response);
                saveAiAnswerCloud(item.id, "append", response).then((id) => {
                  if (id) {
                    response.cloudId = id;
                    if (response.__deleteRequested) deleteAiAnswerCloud(id);
                  }
                });
              }
            );
            stopLoaderPhases(supplementTimer);
            const seconds = Math.max(1, Math.round((Date.now() - startedAt) / 1000));
            const response = {
              answer: result.answer,
              model: result.model,
              seconds,
              arrivedAt: result.arrivedAt || Date.now(),
              answerType: "append"
            };
            pushRuntimeResponse(response);
            saveAiAnswerCloud(item.id, "append", response).then((id) => {
              if (id) {
                response.cloudId = id;
                if (response.__deleteRequested) deleteAiAnswerCloud(id);
              }
            });
            try {
              saveAiSupplementWithLimit(
                supplementKey,
                { text: result.answer, seconds, model: result.model }
              );
            } catch (storageError) {
              console.warn("Failed to persist AI supplement in localStorage", storageError);
            }
          };
          try {
            await executeRequest();
          } catch (e) {
            if (e && String(e.message).includes("INVALID_API_KEY")) {
              pendingRetry = executeRequest;
              updateLoaderText(aiSupplementEl, "Повторяю запрос после сохранения ключа");
              return;
            }
            renderAiSupplement(aiSupplementEl, "Не удалось получить ответ от моделей. Попробуйте позже.");
          } finally {
            aiAppendBtn.disabled = false;
          }
        });
        if (runtimeResponses.length) {
          renderCurrentRuntimeResponse();
        }
      }

      section.appendChild(clone);
    });
  });

  if (authUser) {
    syncLocalAndCloudState({ force: false, source: "post-render" }).catch((e) => {
      console.warn("Post-render cloud sync failed", e);
    });
  }

  // --- Поиск/фильтрация ---
  searchInput.addEventListener("input", () => {
    const term = searchInput.value.trim().toLowerCase();
    const has  = term.length > 0;
    document.querySelectorAll("#accordion-container .t-item").forEach(item => {
      const q = item.querySelector(".t849__title").textContent.toLowerCase();
      const a = item.querySelector(".t849__text").textContent.toLowerCase();
      const match = !term || q.includes(term) || a.includes(term);
      item.style.display = match ? "" : "none";
    });
    document.querySelectorAll("#accordion-container .article").forEach(section => {
      const items      = section.querySelectorAll(".t-item");
      const anyVisible = Array.from(items).some(i => i.style.display !== "none");
      section.style.display = anyVisible ? "" : "none";
      const icon = section.querySelector(".category-icon");
      if (icon) icon.style.display = (has && anyVisible) ? "none" : "";
    });
    clearBtn.style.display     = has ? "inline-block" : "none";
    resultsTitle.style.display = has ? "block"       : "none";
    about.style.display        = has ? "none"        : "";

    if (!has) {
      const selectedFilter = localStorage.getItem("selectedFilter") || "Все";
      if (selectedFilter !== "Все") {
        const selectedKey = normalizeCategoryKey(selectedFilter);
        document.querySelectorAll("#accordion-container .article").forEach(section => {
          const sectionKey = section.dataset.categoryKey || normalizeCategoryKey(section.querySelector(".category-title")?.textContent || "");
          section.style.display = sectionKey === selectedKey ? "" : "none";
        });
      }
    }
  });

  clearBtn.addEventListener("click", () => {
    searchInput.value = "";
    searchInput.dispatchEvent(new Event("input"));
    searchInput.focus();
  });

  const restoreScrollPosition = () => {
    if (!savedScrollY || Number.isNaN(savedScrollY)) return;
    window.scrollTo(0, savedScrollY);
  };
  restoreScrollPosition();
  requestAnimationFrame(restoreScrollPosition);
  setTimeout(restoreScrollPosition, 120);

    loadModels().then(() => {
      if (!shouldWarmup()) return;
      let hasClicked = false;
      let hasScrolledToFirst = false;
      const firstQuestion = document.querySelector("#accordion-container .t-item");

      const checkScroll = () => {
        if (!firstQuestion) return;
        const rect = firstQuestion.getBoundingClientRect();
        if (rect.top <= window.innerHeight * 0.85) {
          hasScrolledToFirst = true;
          tryStartWarmup();
        }
      };

      const tryStartWarmup = () => {
        if (hasClicked && hasScrolledToFirst && shouldWarmup()) {
          warmupModels(currentModels);
          window.removeEventListener("scroll", checkScroll);
          window.removeEventListener("resize", checkScroll);
        }
      };

      document.addEventListener("click", () => {
        hasClicked = true;
        tryStartWarmup();
      }, { once: true });

      window.addEventListener("scroll", checkScroll, { passive: true });
      window.addEventListener("resize", checkScroll);
      checkScroll();
      restoreScrollPosition();
    });
    });  // — конец DOMContentLoaded

// --- Theme toggle ---
(function() {
  const root = document.documentElement;
  const btn  = document.getElementById('theme-toggle');
  const saved = localStorage.getItem('theme');
  if (saved === 'dark' || saved === 'light') {
    root.setAttribute('data-theme', saved);
    btn.classList.toggle('active', saved === 'dark');
  }
  btn.addEventListener('click', () => {
    const next = root.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
    root.setAttribute('data-theme', next);
    localStorage.setItem('theme', next);
    btn.classList.toggle('active', next === 'dark');
  });
})();

// --- Rotating logo/favicons (вне DOMContentLoaded) ---
(function() {
  const imgs = [
    'img/QAtoDev_(Flappy_Bird_style).png',
    'img/QAtoDev_Classic.png',
    'img/QAtoDev_new_year.png',
    'img/QAtoDev_DayQA.png',
    'img/QAtoDev_Halloween.png',
    'img/QAtoDev_BlackAndWhite.png',
    'img/QAtoDev_CoverChatChannel.png'
  ];
  let idx = parseInt(localStorage.getItem('logoIdx'), 10);
  if (isNaN(idx) || idx<0 || idx>=imgs.length) idx = 0;
  const logoImg    = document.querySelector('.logo img');
  const faviconTag = document.querySelector('link[rel="icon"]');
  function updateLogo() {
    const src = imgs[idx];
    if (logoImg)    logoImg.src    = src;
    if (faviconTag) faviconTag.href = src;
  }
  updateLogo();
  setInterval(() => {
    idx = (idx + 1) % imgs.length;
    localStorage.setItem('logoIdx', idx);
    updateLogo();
  }, 50000);
})();

/**
 * @param {string} category
 * @param {number} studiedCount
 * @param {number} unclearCount
 * @param {number} total
 */
function updateProgress(category, studiedCount, unclearCount, total) {
  const pctStudied = (studiedCount / total) * 100;
  const pctUnclear = (unclearCount  / total) * 100;
  const blueBar   = document.querySelector(`.progress-bar[data-category="${category}"]`);
  const orangeBar = document.querySelector(`.progress-bar-unclear[data-category="${category}"]`);
  const text      = document.querySelector(`.progress-text[data-category="${category}"]`);
  if (unclearCount > 0) {
    blueBar.classList.add('split');
    blueBar.classList.remove('full');
  } else {
    blueBar.classList.add('full');
    blueBar.classList.remove('split');
  }
  blueBar.style.width   = pctStudied + '%';
  orangeBar.style.left  = pctStudied + '%';
  orangeBar.style.width = pctUnclear + '%';
  text.textContent      = Math.round((studiedCount / total) * 100) + '%';
}

// ======== Фильтрация по категориям ========
document.addEventListener('DOMContentLoaded', () => {
  // Ждем полной загрузки DOM перед работой с фильтрами
  function normalizeCategoryKeyLocal(category) {
    const value = String(category || "")
      .replace(/\s+/g, " ")
      .trim()
      .toUpperCase();
    if (!value || value === "ВСЕ") return "ALL";
    if (value === "БД" || value === "БАЗЫ ДАННЫХ") return "БАЗЫ ДАННЫХ";
    if (value === "GIT" || value === "GIT + IDE" || value === "GIT + IDE + SELENIUM") return "GIT";
    if (value === "ТЕОРИЯ") return "ТЕОРИЯ ТЕСТИРОВАНИЯ + СОФТЫ";
    return value;
  }

  const categoryFilters = document.getElementById('category-filters');
  const categoryFiltersBottom = document.getElementById('category-filters-bottom');
  const searchInputEl = document.getElementById('search-input');
  if (!categoryFilters) return;
  const filterChips = categoryFilters.querySelectorAll('.filter-chip');
  const bottomChips = [];

  // Клонируем чипы в нижнюю панель
  if (categoryFiltersBottom) {
    filterChips.forEach(chip => {
      if (chip.dataset.category === 'Все') return;
      const clone = chip.cloneNode(true);
      if (clone.dataset.category === 'БАЗЫ ДАННЫХ') {
        clone.textContent = 'БД';
      }
      if (clone.dataset.category === 'GIT + IDE + SELENIUM') {
        clone.textContent = 'GIT';
      }
      categoryFiltersBottom.appendChild(clone);
      bottomChips.push(clone);
    });
  }

  const allChips = [...filterChips, ...bottomChips];

  // Модифицированная функция фильтрации
  function applyCategoryFilter(category) {
    const sections = document.querySelectorAll('#accordion-container .article');
    const wanted = normalizeCategoryKeyLocal(category);

    sections.forEach(section => {
      const sectionTitle = section.querySelector('.category-title')?.textContent || "";
      const sectionKey = section.dataset.categoryKey || normalizeCategoryKeyLocal(sectionTitle);
      section.style.display = (wanted === "ALL" || sectionKey === wanted) ? '' : 'none';
    });
  }

  function scrollToCategory(category) {
    const sections = document.querySelectorAll('#accordion-container .article');
    const wanted = normalizeCategoryKeyLocal(category);
    const targetSection = wanted === "ALL"
      ? sections[0]
      : [...sections].find(section => {
          const sectionTitle = section.querySelector('.category-title')?.textContent || "";
          const sectionKey = section.dataset.categoryKey || normalizeCategoryKeyLocal(sectionTitle);
          return sectionKey === wanted;
        });
    if (targetSection) {
      const headerOffset = 120;
      const rect = targetSection.getBoundingClientRect();
      const top = window.pageYOffset + rect.top - headerOffset;
      window.scrollTo({ top: Math.max(0, top), behavior: 'smooth' });
    }
  }

  function setActive(category) {
    const wanted = normalizeCategoryKeyLocal(category);
    allChips.forEach(c => {
      c.classList.toggle('active', normalizeCategoryKeyLocal(c.dataset.category) === wanted);
    });
    if (categoryFiltersBottom) {
      const activeBottom = [...categoryFiltersBottom.querySelectorAll(".filter-chip")]
        .find(chip => normalizeCategoryKeyLocal(chip.dataset.category) === wanted);
      if (activeBottom) {
        const container = categoryFiltersBottom;
        const chipRect = activeBottom.getBoundingClientRect();
        const contRect = container.getBoundingClientRect();
        const current = container.scrollLeft;
        const target = current + (chipRect.left - contRect.left) - (contRect.width / 2) + (chipRect.width / 2);
        container.scrollTo({ left: Math.max(0, target), behavior: 'smooth' });
      }
    }
  }

  // Восстановление состояния после полной загрузки
  function restoreFilterState() {
    const savedFilter = localStorage.getItem('selectedFilter');
    const activeChip = [...filterChips].find(
      chip => normalizeCategoryKeyLocal(chip.dataset.category) === normalizeCategoryKeyLocal(savedFilter)
    );

    if (activeChip) {
      setActive(savedFilter);
      if (categoryFiltersBottom) {
        setTimeout(() => setActive(savedFilter), 0);
        setTimeout(() => setActive(savedFilter), 50);
        setTimeout(() => setActive(savedFilter), 150);
      }
      // Добавляем небольшую задержку для гарантированного рендера карточек
      setTimeout(() => {
        applyCategoryFilter(savedFilter);
      }, 50);
    } else {
      // По умолчанию активируем "Все"
      setActive('Все');
      localStorage.setItem('selectedFilter', 'Все');
      applyCategoryFilter('Все');
    }
  }

  // Обработчики для чипов
  allChips.forEach(chip => {
    chip.addEventListener('click', () => {
      setActive(chip.dataset.category);

      const category = chip.dataset.category;
      localStorage.setItem('selectedFilter', category);

      // Очищаем поиск
      if (searchInputEl) {
        searchInputEl.value = '';
        searchInputEl.dispatchEvent(new Event('input'));
      }
      applyCategoryFilter(category);
      scrollToCategory(category);
    });
  });

  // Инициализация после полной загрузки
  restoreFilterState();

  // Показ нижней панели: скрываем только когда верхние чипы реально видны пользователю
  if (categoryFiltersBottom && categoryFilters) {
    const headerOffset = 120; // высота фиксированного хедера
    const updateBottomVisibility = () => {
      const rect = categoryFilters.getBoundingClientRect();
      const fullyVisible =
        rect.top >= headerOffset &&
        rect.bottom <= window.innerHeight;
      categoryFiltersBottom.classList.toggle('visible', !fullyVisible);
    };
    window.addEventListener('scroll', updateBottomVisibility, { passive: true });
    window.addEventListener('resize', updateBottomVisibility);
    updateBottomVisibility();
  }
});
